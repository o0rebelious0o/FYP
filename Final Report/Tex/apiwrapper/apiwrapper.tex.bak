\chapter{Exam Data API Wrappers}

\label{ch:apiwrappers}

With the technologies making up each component of the system decided, Node.JS for back-end server, Android for the client application , it was necessary to consider how the various aspects of the exam and invigilation system would be pulled in to populate it.

DoC (Department of Computing) already had an API accessible which could be queried and exposed the exam schedule for the exam session with information such as start and finish times, module codes, number of questions etc. and provided the information necessary to adequately represent system state in the server.

Similarly available was a seating plan for the exam session with CIDs and seat numbers for each exam, but there was no API exposing it, partially because CID numbers and seat numbers are protected until the morning of the exam, and couldn't be shared even with the data being from a previous exam season.  As a result, what was provided to me by the department was a tab separated value file with mock data such as CIDs for each seat in the exams provided through the exam schedule API.

Since all data was provided in tab separated value form, and so more obtuse to work with, and with the principle of separation of concerns \cite{sepofconcerns} in mind, I decided to implement a separate API server capable of transforming the provided TSV (Tab Separated Value) data provided to work with into a more usable JSON format with the ability to filter and refine results, such as select a period of time within which to return results, or narrow seating plans down to those in a particular room.

By transforming the data into JSON and using a separate API server, also implemented in Node.JS, other systems could make use of the data, and if at a later stage the DoC servers were updated to offer a JSON API or even extended to provide more data, ExICS URLs (Uniform Resource Locator) could simply be updated to point to the new data source, without breaking any existing functionality.

\section{Input Data}

In order for the Exam Data API Server to process and return the data requested in the required view, it is necessary for the server to fetch the original data, provided by DoC, and process it to generate the required respose for the user.

\subsection{Exam Data}
\label{subsec:examData}

\FloatBarrier

The Exam Data information has been made available using a CGI API running in DoC at \url{https://146.169.13.35/prog/ttformjw03.cgi}.

The API simply takes the original from its original source on the DoC machine, and outputs simple tab separated values representing the exams in the exam session, sorted chronologically.  A sample of the output returned by the API is shown in figure \ref{fig:exam_data_api}

\begin{figure}[!htbp]
\centering
\begin{lstlisting}[tabsize=2,breaklines=true]
%Printed at Sat Jun 14 11:57:47 BST 2014
%Examination timetable 2012-2013
%Tab-separated text
%Exam/Subexam	Title	NumQns	Date	Time	Duration	Room
C350	Management and Business for Computing Engineers	6	18-Mar	15:00	120	344+308
C481	Models of Concurrent Computation	4	29-Apr	10:00	120	308
C231=MC231	Introduction to Artificial Intelligence	2	29-Apr	10:00	75	341+344
\end{lstlisting}
\caption{Sample Output from Exam Data API}
\label{fig:exam_data_api}
\end{figure}

The ancillary data provided by the API, such as academic year and date produced is provided at the beginning of the data output, prepended by a percentage symbol.  The column titles are then provided, again prepended by a percentage symbol, followed by the exam information with one entry per line.

\FloatBarrier

\subsection{Seating Plan Information}
\label{subs:seating_plan_info}

\FloatBarrier

Unlike the exam data information which was made available through an API hosted on DoC Servers, the seating plan information is generated and stored as a Microsoft Excel spreadsheet which can be exported to a CSV (Comma Separated Value) file containing tab separated values, an example of which is shown in figure \ref{fig:seating_plan_data}.

\begin{figure}[!htbp]
\centering
\begin{lstlisting}[tabsize=2,breaklines=true]
#desk numbers generated by gendesk.cgi Wed Apr 24 16:20:50 BST 2013						
18-Mar	15:00	344+308	C350	b3	1	884756
18-Mar	15:00	344+308	C350	b3	2	632912
\end{lstlisting}
\caption{Sample of Seating Plan Data}
\label{fig:seating_plan_data}
\end{figure}

The seating plan file contains the date and time of that seating entry, the room the entry is for, and the exam that the student is taking.  It also provides the group that the student is from, for example EIE4 (Electronics and Information Engineering Year 4), the seat at which the student is sitting in that room for that exam, and the students CID (Candidate ID) number.

\FloatBarrier

\section{Exam Wrapper API Server Design}

\FloatBarrier

As mentioned in chapter \ref{ch:systemarchitecture}, it was decided based upon the research done that the back-end servers of ExICS would be implemented using Node.JS thanks to its great performance, ease to work with and great support library availability through NPM, and efficiency.\cite{understandingNode}

The Exam Data wrapper is designed to be useful to not just ExICS, but others wishing to use the data provided.  It is intended to be useful as an open API for those in the department to utilise and so features documentation of the APIs available.

The Exam Data API Server node.js "app" features two servers which run simultaneously on different ports.  One server is HTTP, with the other HTTPS.  Beyond the difference in the connection protocol, both servers offer the same functionality to the connecting user.

When a request is received, the server logs the event onto the console and checks the request header for authorization parameters; these will be explained in more detail in section \ref{sec:security_wrapper}.  If the request does not contain authorization parameters in the header the server issues a response with HTTP status code 401 meaning that authentication is required, prompting the users' browser to display a login dialog requesting their Imperial credentials.  Should the user choose not to enter credentials, the browser will display a simple error message stating that authentication is required to access the resource.

Once the received request contains authorisation headers, the request url is parsed to break it down into its query path and the following get request variables.  These parameters are then passed to a query router which decides which component of the server is required to handle the request being made.

The request router contains a map of request path names to functions implemented to serve the request to the path.  When a request is passed to it to be routed, the path of the resource trying to be accessed by the user making the request is analysed and the router verifies that a function to deal with the request exists.  If the path attempted to be accessed does not have a handle to serve it, the user is served a HTTP code 404 saying that the requested resource cannot be found on the server, otherwise, the function to handle the request is invoked.

The API server has four resources that can be requested by users, the exam data API and its documentation, and a call to the seating plan API and its documentation.  Calls to the root of the web server (``/'') receive a HTTP code 302, a redirection to the exam data API documentation page.

The function handler for each request type is unique and produces the output to be returned to the user, as explained below.

\subsubsection{Exam Data Request Handler}

\label{subsec:exam_data_handler}

The Exam Data API request handler contains a map of five data converting function which correspond to different views the exam data can be represented with:

\begin{itemize}

\item Default View\\
	This is the default view used if no view type is specified in the request.  It simply converts the tab separated data provided by the DoC API into JSON form and returns it with no processing.  This is also the view returned by the API if no view type is specified by the user in their request.

\item Date View\\
	In this view examinations are grouped according to the date on which they occur.

\item Yeargroup View\\
	In this view, examinations are grouped by the yeargroup taking them, as identified by the course code of the examination.

\item Room View\\
	In this view, examinations are grouped by the room in which the exam is being taken.

\item Session View\\
	In this view, examinations are grouped by DoC examination session.  Exams are grouped by date on which they are taking place, then subdivided into those taking place in the morning session (between midnight the night before and 1.30pm) or afternoon session (1.30pm until midnight that day).

\item ExICS View\\
	The ExICS view is the most customisable view in which the exam data can be represented.  The API returns a simple JSON array of all exams taking place as requested, however, in this view, the date range in which to select can be specified.  All examinations have an ISO8601 \cite{iso8601} JSON time stamp calculated, rather than returning the data in a simple Date-Month format meaning it can be parsed to instantiate Java calendar objects, for example, and allowing comparison with provided session start and end parameters.\\
	This View accepts two get parameters with the request, startSession and endSession, both of which must be ISO8601 formatted JSON timestamps.  When unspecified, the Server defaults the values to the earliest and latest possible, respectively, encompassing all of representable time and so including all exams within the period.

\end{itemize}

Each data view returns a JSON string, prettyprinted to be human readable for if accessed by a client using a browser rather than programmatically.

To generate the users response, the handler function first makes a HTTPS get request to the exam data URL shown in section \ref{subsec:examData}.  For this request, the server uses the authorization header provided when the user connected as authorization for the DoC API.

If the server receives a HTTP response status code other than 200, Success, the likelihood is that the credentials provided to the server upon connection were rejected by the DoC API and so the user is sent a response with HTTP code 403: Forbidden.  If the request from data is successful, then the server receives the csv data ready for processing.  This data is then passed to the view handler associated with the requested or default view to generate the data output.

To generate the JSON data output which will be returned the view handling function first processes the exam information headers to extract the information about when the data was produced by the DoC API, the exam session and headers for the main body of data.  A response object is then created, containing the information about when the data was produced, the view being returned and academic year information with a key containing another Javascript object which will hold the exam data itself.

The function then walks the data line by line, building a Javascript ``Exam'' object which contains key-value pairs of column header and value for that exam.  The function then decides, based upon the view being returned, the stucture of what the exam data response should look like, and inserts the exam object into the final result.

More complicated is the ExICS view function which has to build a Date-Time object representing when the exam will take place by manipulating the strings of data such as academic year and date provided by the original API.  Code performing the operation is shown in figure \ref{fig:buildingDate}.  In the code snippet shown, examTime is the time given in the time column of the exam row, examDate is from the date column and examYears[0] is the start year of the academic year the data is from.

\begin{figure}[!htbp]
\centering
\lstset{language=JavaScript}
\begin{lstlisting}[tabsize=2,breaklines=true]
var examDateTime = new Date(Date.parse(examTime + " " + examDate.split("-").reverse().join(' ') + " " + examYears[0]));

if (examDateTime.getMonth() <  10){
	examDateTime.setFullYear(examYears[1]);
}

examObj[headers[datePosition]] = examDateTime.toJSON();
\end{lstlisting}
\caption{Code to Construct a Javascript Date Object from the Provided Examination Data}
\label{fig:buildingDate}
\end{figure}

The date object is created using the parse method of the Date class, which parses a string of the form `\textless time \textgreater \, \textless month \textgreater \, \textless date \textgreater \, \textless year \textgreater', e.g (12:31 Jun 6 2014).  Once in date form, the date and time of the exam can be compared to the Date object created by parsing the ISO8601 date passed in for session start and or end to establish if the exam begins within the specified period, and if so the exam object is pushed to the response object.

Finally, the response object constructed is stringified using the `JSON.stringify()' and pushed to the user with a HTTP code 200: OK under a content-type of json specified in the response header.

\FloatBarrier

\subsubsection{Seating Plan Request Handler}

The seating plan response handler works slightly differently to the exam data handler as explained in section \ref{subsec:exam_data_handler} on account of the data being stored in a file locally on the server.

To keep authorization permissions for the seating plan data the same as the exam data, the handler makes a request to the DoC exam data API, as the exam data handler does, with a HTTP 403: Forbidden being sent to the user if an error occurs making the request.  If the request is sucessful however, the response is discarded and the seating plan file is read from disk and passed to the seating plan data converted function to be processed.

The seating plan API can take four parameters in the query, sessionStart and sessionEnd, as with the ExICS view of the exam data, but also a room and course parameter.

By default, as with the exam data API, sessionStart and sessionEnd are set to encompass all of representable time, and the room and course selector parameters default to unset.

The date produced is extracted from the header line of the data from the file, and since headers are not provided in the file, they are hardcoded into an array mapping to the order data is stored in each seating plan information row.

The response object is created which contains the date the data was produced and utilized sessionStart and sessionEnd in ISO8601 form.  There is then a Seating Plan key holding an object which contains the seating plan information being returned.

The function then iterates over each row to build an exam data object from the data contained in each row, held in a JSON object of key-value pairs of column title and value for that seating plan row.

As with the exam data ExICS view handler, a Date object is created from the information provided by the original data which can be compared to the Date formed by the sessionStart and sessionEnd parameters.  If the seating plan information is relevant for the specified time period, the function then examines room and course code for the exam and request.  If neither, either/or/both are set and match the details for the seating plan information, the object is inserted into the results object, else it is discarded.

Finally, as with the exam data API, the results object is converted into a JSON standard string and returned to the client prettyprinted under the JSON content type in the HTTP header.

\subsubsection{API Documentation Request Handler}

The API Documentation request handler is much simpler than the API handlers and both the handler for exam data documentation and seating plan documentation work very similarly.

When a request is made for API documentation, the relevant handler is invoked by the router, as with the APIs above.  The handler then makes a request to the DoC exam data API using the authorization header from the request as authorization to the request to the DoC APS. As with the seating plan API above, if the request is unsuccessful, the user is served a HTTP 403: Forbidden response, otherwise the response from the API is discarded.

If successful, the API server loads a html page containing the API documentation and sends it to the user under the HTTP header content type text/html.

\subsection{Output Data}

\FloatBarrier

The Exam Data API server is designed to wrap the existing exam information and seating plan represented in a tab separated values format and transform it into a form that is easier to work with.

Whilst CSV format has the advantage that it can be approximately half the size of its JSON counterpart, due to the repeated inclusion of header information in JSON \cite{csvVsJSON}, JSON data has the advantage that it can be very simply parsed by JSON libraries to instantiate objects or directly access elements and properties by name.  It means that data can change in order, with more added and existing functionality will remain unbroken.

The form of the data returned by requests depends upon te type of data requested, exam data, or seating plan information.  With exam data, different data views which are structured differently can be requested by the user, and customised with additional request parameters in the case of ExICS view, see figure \ref{fig:samp_exam_data_output}.

\begin{figure}[h]
	\begin{subfigure}[b]{0.9\textwidth}
		\centering
		\lstset{language=JSON}
		\begin{lstlisting}[tabsize=2,breaklines=true]
		{
		  "dateProduced": "Sat Jun 14 16:06:52 BST 2014",
		  "examPeriod": "2012-2013",
		  "sessionStart": "2013-05-01T23:01:00.134Z",
		  "sessionEnd": "2013-05-02T12:30:00.135Z",
		  "view": "ExICS",
		  "exams": [
		    {
		      "Exam/Subexam": "C223=MC223",
		      "Title": "Concurrency",
		      "NumQns": "2",
		      "Duration": "75",
		      "Room": "219",
		      "Date": "2013-05-02T09:00:00.000Z"
		    },
		  	...
		 	]
		}
		\end{lstlisting}
		\caption{Sample Output from Exam Data API with ExICS View}
		\label{subfig:ExICS_view}
	\end{subfigure}
	\newline
	\begin{subfigure}[b]{0.9\textwidth}
		\centering
		\lstset{language=JSON}
		\begin{lstlisting}[tabsize=2,breaklines=true]
		{
			"dateProduced": "Sat Jun 14 15:59:07 BST 2014",
		  "examPeriod": "2012-2013",
		  "view": "Default",
		  "exams": [
		    {
		      "Exam/Subexam": "C350",
		      "Title": "Management and Business for Computing Engineers",
		      "NumQns": "6",
		      "Date": "18-Mar",
		      "Time": "15:00",
		      "Duration": "120",
		      "Room": "344+308"
		    },
		  	...
		  ]
		}
		\end{lstlisting}
		\caption{Sample Output from Exam Data API with Default View}
		\label{subfig:default_view}
	\end{subfigure}
	\caption{Sample Exam Data API Output}
	\label{fig:samp_exam_data_output}
\end{figure}

Figure \ref{subfig:ExICS_view} shows a small amount of the response for a request for exams beginning between midnight on May 1st 2013 and 1.30pm on May 2nd.  It can be seen that exam C223, Concurrency has been returned, beginning at 10AM on May 2nd.

Figure \ref{subfig:default_view} shows a sample of the response for the default view.  This view will return the exam information for all exams available from the original exam data API.

\FloatBarrier
\FloatBarrier

Figure \ref{subfig:seating_plan} shows a sample of the data returned from a query to the seating plan API where sessionStart is midnight on May 1st, sessionEnd is 1.30PM May 2nd and the specified room is room 344.  The data returned will feature seating information for all students taking exams in room 344 during this session.  I can be seen from this information that JMC4 (Joint Maths and Computing Year 4) student 481608 is taking exam C438 beginning at 10AM on 2nd May.

\begin{figure}[h]
	\centering
	\lstset{language=JSON}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	{
		"dateProduced": "Wed Apr 24 16:20:50 BST 2013",
		"sessionStart": "2014-05-01T23:00:54.308Z",
		"sessionEnd": "2014-05-02T12:30:48.119Z",
		"SeatingPlans": {
			"2-May": {
				"341+344": [
					{
						"Date": "2-May",
						"Time": "10:00",
						"Room(s)": "341+344",
						"Course": "C438",
						"Class": "jmc4",
						"Seat": "1",
						"CID": "481608"
					},
				...
				]
			}
		}
	}
	\end{lstlisting}
	\caption{Sample Output from Seating Plan API}
	\label{subfig:seating_plan}
\end{figure}

\FloatBarrier

\subsection{Documentation}

\FloatBarrier

The Exam Data API server features documentation for each of the APIs available for use and can be found at \textless Server Address \textgreater / \textless API Name \textgreater /apidoc.

The documentation explains the API and any associated views which can be chosen to represent that data.  It explains the structure of the API, the data it returns, and any option parameters that can be accepted and what they do.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{"screenshots/Exam Data API"}
	\caption{Screenshot of the Exam Data API Documentation Page}
	\label{fig:exam_data_apidoc}
\end{figure}

\FloatBarrier

\section{Security}
\label{sec:security_wrapper}

The API Wrapper server, like the preexisting DoC API providing information uses Basic HTTP authentication for sharing credentials for use in authenticating the user.

Basic HTTP authentication involves sending a base-64 encoded string of ``\textless username\textgreater :\textless password\textgreater'' in the HTTP header of the request to the server.\cite{basicAuth}

This string can then be decoded and separated around the colon to retrieve the username and password of the connecting client and verify their identity and right to access the resource.

\subsection{SSL}

Due to the security issues of transmitting these credentials ``in the clear'', as defined by the W3C consortium\cite{intheclear}, the API server offers a HTTPS connection allowing the insecure data to be sent securely by taking advantage of the secure underlying protocol.

The server features self-signed certificates which could pose a security issue, should an adversary choose to attempt to impersonate the API server.  However, given that the API server is only accessible from within the secure Imperial network, self-signed certificate offered an acceptable level of security for the purposes of development.

Should the system become more widely used in future, it would be high on the list of priorities to have the API server running on a dedicated host with static IP and obtain signed certificates from a trusted CA (Certificate Authority).  It may also be possible to investigate other more secure ways of transmitting the user's credentials such that there is a second layer of security on top of HTTPS.
