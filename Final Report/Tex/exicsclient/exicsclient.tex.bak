\chapter{ExICS Client}

\label{ch:exicsclient}

\section{Initial Design Sketches}

For and Android client GUI concept designs I decided to use a traditional pen and paper rapid prototype methodology.  By using pen and paper I was able to focus more on the general design of the application rather than beautifying or concentrating on details.

The client application designs are based upon the screen size and resolution of a Google Nexus 7 tablet and are drawn to scale.  Since the department of computing is already in possession of primarily tablets, this is the form factor I will be primarily designing for.  The code will be implemented using Android fragments\cite{fragments} such that, if there is sufficient time, it should be a relatively trivial task to create a usable layout design for phone form factors.  To simplify development, the application will also enforce landscape device rotation.

\includegraphics[width=\textwidth]{"GUI Sketches/Main Overview Cropped"}

The main overview page for the application will consist of a dual pane android layout using fragments.  2/3 of the screen will be dedicated to overview information, with the remaining 1/3 containing the log of most recent system communication activity.

The main overview content will be divided again roughly in two.  The top panel will contain a horizontally scrollable list of the rooms currently containing examinations, the invigilators/examiners currently linked to that room, and the rooms status; ok, stopped, or pending help, along with a traffic light icon reflecting the status.  The rooms are selectable, shown by highlighting which updates the information shown in the lower panel.

The initial concept for the lower panel of the main overview content is that it will contain another horizontally scrollable panel containing an entry for each exam taking place in that room.  Each entry will show the name of the room, and timing information depending upon the state of the exam.  Before the exam is started, the scheduled start time will be shown, with this changing to show the actual start time, time remaining, finish time, and extra time finish time.  If an exams time is extended, this can be reflected also, by appending an extra time flag to the finish time, for example

\begin{minipage}{\textwidth}
\begin{lstlisting}[captionpos=b,caption=Representation of Examination Timings, tabsize=4, breaklines=true]

 12:01							 12:02
	1:35			becomes			  1:44
 14:01							 14:11 (+0:10)
(14:31)							(14:41)(+0:10)

\end{lstlisting}
\end{minipage}

The exact method of enhanced functionality, such as how to extend the time of an exam for example are yet to be decided pending evaluation of the initial concept sketches.

\includegraphics[width=\textwidth]{"GUI Sketches/Side Menu View Cropped"}

The client application will feature an always available side bar menu available to the left hand side of the screen.  This will contain the navigation buttons to move to different activities within the android application.

The slide in menu may be implemented using either the inbuilt Navigation Drawer\cite{navdrawer} or using a third party library such as slidingPaneLayout\cite{spl}.  The main differences between these two implementation techniques are that the android Navigation Drawer overlaps the screen content, leaving the log visible at all times, whereas with the SlidingPaneLayout, it would be possible to achieve the effect shown in the sketch where the log is slid off the right side of the screen, with the menu taking up the left 1/3 of the screen.

\includegraphics[width=\textwidth]{"GUI Sketches/Help Request Window Cropped"}

The request help screen will allow the user to send a message requesting assistance to other users on the system.  They will be able to select send to all, send to examiners or send to specific users, with send to all the default choice.  They can then select the nature of the message whether it is a generic assistance needed message, a preset advanced message such as request for more paper or a toilet escort, or a manually typed specific message.

\includegraphics[width=\textwidth]{"GUI Sketches/Message Notification Cropped"}

Received messages when received by the client will be buffered for notification purposes.  One at a time a notification will be displayed on screen and the device will optionally vibrate to alert the user.  The message and the sender will be displayed, along with a time stamp.

The alert window will feature a number of responses which the user can make use of which will vary by nature of the alert being displayed.  The user can optionally choose to dismiss the message with no action being taken, in which case no response will be sent to the sender except for announcement requests, in which case even if dismissed the sender will be notified that the message has been seen.  If an announcement is positively responded to, such as by saying that the user is on their way to help, the message will be dismissed or removed from the queue on all other devices to prevent over servicing of requests.

\includegraphics[width=\textwidth]{"GUI Sketches/Seating Plan Cropped"}

The seating plan part of the system will allow a user to view the seating plan for a selected room giving the student names, CID (College ID) numbers and seat numbers.  This list will be sortable by name or by seat number and there will be a search functionality for looking up seating positions based on name/CID or a reverse lookup to identify missing students based on seat number.

\section{ExICS Client Architecture}

The ExICS client application is implemented with a variation of a design pattern originating from Microsoft, commonly known as MVVM (Model-View-ViewModel)\cite{mvvm}.  With the MVVM pattern, core system data and state are stored using Models (classes) contained within ViewModels.  These can be accessed and represented in different application views which select the data they wish to ``bind'' to from the ViewModel.  This design pattern is incredibly popular on the Windows and WindowsPhone platform due to its simplicity, as it removes the need to control scope of state data or pass it between different views.

Since the MVVM pattern is designed and used by the Microsoft developer community in its true form, many of the features facilitating the design pattern, such as XAML Data binding\cite{dataBinding} are unavailable on the Android Operating System.  As a result, it was necessary to emulate the functionality by storing the examination and client information in a singleton (ViewModel), and use custom data view adapters (for ListViews, Spinners etc.) to bind the view elements to the underlying data held in the ViewModel.

During the implementation phase, having done some experimentation with the Windows Platform for development, use of Windows/WindowsPhone (universal applications which run on both platforms from a unified codebase are possible) was considered.  However, due to lack of market penetration of the Windows platforms, particularly WindowsPhone or Windows powered tablets, and especially in the Department of Computing, it was decided that the decision would reduce the possible userbase of the system too greatly to justify, even with simplified implementation.

\subsection{System State}

\FloatBarrier

As mentioned in the introduction to this section, Android does not support the language features present in Windows C\# and XAML development which make implementation of the MVVM design pattern so easy to do.

It was therefore necessary to implement some of the features manually to achieve the same functionality.  For the ViewModel component of the system, this is done using a Java singleton object, ExICSSystemData.  A template for a lazy instantiated singleton in Java is shown in figure \ref{fig:java_singleton}  As with the ExICS server, the singleton design pattern is used for the data object so that it can be referenced from any other class, including Android activities and fragments\cite{fragments}.  This allows a single object containing system state to be instantiated and used to populate multiple application views, even concurrently, with no need to pass data or worry about data scope.

\begin{figure}[h]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	public class mySingleton {

		//Private Variables

		//Instance Variable
			private static mySingleton instance = null;

			//Private Constructor, Called by getInstance when Needed
			private mySingleton() {
			}

			public static mySingleton getInstance() {
					synchronized (mySingleton.class) {
						//If Instance has not been Instaciated
							if (instance == null) {
									instance = new mySingleton();
							}
							return instance;
				}
			}
			//Other Methods
	}
	\end{lstlisting}
	\caption{Java Lazy Instantiated Design Pattern}
	\label{fig:java_singleton}
\end{figure}

The ExICSData class contains the local information about the client and the state of the system.  As with the ExICS server, the state of the current exam sessions, and the exams taking place, as well as the clients connected to the system.

The exams running in the current session are stored in a HashMap where an integer, the room number exams are taking place in, map to an ArrayList of Exam objects implemented using the schema defined in section \ref{sec:exics_objs}.

The users currently connected to the system are also stored in a HashMap data structure which maps Strings, the username of the peer, to a Client object containing the username and room of the client.

The ExICSSystemData object also holds a string representing the system activity history log which can be bound to to create the Log feature of the user interface.

The ExICSSystemData class also features a large number of methods which can be used to fetch and manipulate the system state data providing data objects which can be bound to.  For example, there is a method, ``getAllRooms'' which returns a Set of Integers of all rooms in which exams are taking place.  This set can be processed and bound to, for example, a Spinner view element (drop down menu) to populate the room list in the send message dialog, allowing the user to specify which room to send a message to all users in.

\FloatBarrier

\subsection{Websocket Manager}

As with the ExICSSystemData Class, the wsCommunicationManager class used in the ExICS client application is implemented using a lazily instantiated singleton object.  This allows only one instance of the websocket to be created which can be accessed from any other class, including both interactive, such as Android Fragments and utility, like ExICSSystemData.

The wsCommunicationManager class is implemented making use of the Autobahn Android websocket library, as explained in section \ref{subs:exics_client_platform}.  The object contains a WebSocketConnection object as provided by the Autobahn Android library which offers a simple to use interface of methods which can be used to establish, utilize and manage the websocket connection.

The wsCommunicationManager offers a number of methods which can be used by other classes to manage and use the websocket connection once made to the server, for example the connectToServer method which takes a String, hostname, and Integer, port, and establishes a connection to the hostname on the specified port with the WebSocketConnection object.

The Autobahn Android websocket library is used in a very similar way to the Node.JS websocket packages.  Callback handlers are assigned to different websocket events exposed by the Autobahn libary, such as ``onTextMessage'', which are invoked when the specified event takes place.

When a new text message is received from the server, it is handled in much the same was as on the ExICS server.  The message header type is used in a switch statement where the case for each ExICS message type, as defined in section \ref{sec:api_design}, contains the code to handle the message.

If a SYSTEM\_STATE message is received for example, the current state of the system, contained by the ExICSSystemData object, is cleared, and the processSystemData method is called and passed the payload of the received message.  This method extracts the JSONArray containing the current clients connected to the system and the JSONObject containing the current exam state.  These objects can then be iterated over by the addUsers and addExams methods which reconstruct Java objects from the JSON representations and store them in the ExICSSystemData object for use by the rest of the client application.

\subsubsection{Android LocalBroadCasts}

When the wsCommunicationManager class handles a message received from the server, it means something in the system state has changed.  Whether that is a new message received from a peer, or an exam that has been started/paused/stopped etc.  When these changes occur, it is therefore necessary for any system state representation on the user interface to be refreshed to ensure that it is showing the current state of the system.

In WindowsPhone and Windows, the operating system features data binding from XAML user interface components.  When a user interface component is bound to a data source, the operating system automatically generates the glue between the View and ViewModel such that when the data in the ViewModel is changed programmatically, the UI (User Interface) View automatically refreshes to reflect the changes.  Similarly, if the UI View is interacted with by the user to modify the representation of the data, the underlying data will also be mutated.

With Android, however, this functionality does not exist and so it was necessary to implement it manually.  Implementing update of the underlying data when the UI View is interacted with was a simple task.  When a UI view is interacted with, clicked, toggled, selected, an event listener callback calls a method on the ExICSSystemDataClass which mutates the underlying data or calls the wsCommunicationManager to request a state change from the server.

Reflecting underlying state changes in the UI View when changed however, is not as simple.  There are a number of ways of implementing such behaviours such as each UI View element registering a callback function with the ExICSSystemData class that can be called to trigger a UI refresh etc.  This involves a level of complexity, however, where connected listeners must be handled carefully; registered correctly when a View is instanciated, and unregistered when destroyed to avoid any errors in the code such as NullPointer Exceptions, where a referenced object no longer exists, or the reference is null and doesn't actually point to an object (In java, there are no explicit pointer types, all references to objects are implicity pointers).

Instead, the ExICS client app makes use of a built-in Android functionality which build upon the Android Intent System using LocalBroadCastManager\cite{localBroadcastAndroid}.  The LocalBroadcastManager allows components of the application system, in this case the wsCommunicationManager, to send messages which are carried by Android and can be listened for by other components of the application.

The messages sent are Android Intent objects\cite{androidIntents} which can contain information, or simply be designed to trigger events in application components when receieved, as they are used in the ExICS client.

There are six broadcasts that are used by the ExICS client:

\begin{itemize}

\item AUTH\_SUCCESSFUL\\
	This broadcast is made after the client application has sent a PROTOCOL\_HANDSHAKE message to the server, and the server has responded that authentication was successful.

\item DATA\_UPDATED\\
	This broadcast is sent after a SYSTEM\_STATE message is received from the server and is used to trigger listening UI components to refresh Views populated from the ExICSSystemData ViewModel.

\item CONNECTION\_CLOSED\\
	The CONNECTION\_CLOSED broadcast is made when the websocket connection to the server is closed.  This is used such the the application can attempt to reconnect to the server if the connection drops.

\item FAILURE\_OCCURRED\\
	This broadcast is made when a FAILURE message is received from the server and contains the reason provided by the server.  This is so that the UI can notify the user of the failure and the reason.

\item LOG\_UPDATED\\
	This broadcast is made so that any UI components using the activity log held in the ExICSSystemData class can refresh their content.

\item MESSAGE\_RECEIVED\\
	This broadcast is made when a message from another client in ExICS is received.  The message is contained within the broadcast so that any listening component can process it.

\end{itemize}

The wsCommunicationManager class has a number of private methods which are called whilst processing received messages which obtain a reference to the Android LocalBroadcastManager, generate the intent for the broadcast, and send it, ready to be received by listening components.

In the code wishing to receive notification of the broadcast, a reference to the LocalBroadcastManager is obtained and a callback function is attached with an intent receiver, the tag that is checked to determine if the broadcast heard is of the correct type to trigger the callback to be invoked.

In the main Android UI Activities, lifecycle callbacks ``onCreate'', called when the Activity is first created, and ``onDestroy'', called when the Activity is finally destroyed contain calls to methods to register and unregister all broadcast receivers, again, to avoid NullPointer issues once the Activity is destroyed and so listeners no longer exist.

\subsection{User Interface}

\FloatBarrier

Making use of the system state stored by the ExICSSystemData class and network functionality provided by the wsCommunicationManager class is the user interface.  The user interface of the application is designed in XML (Extensible Markup Language), with app-logic written in Java making use of the Android SDK (Software Development Kit).

The application targets Android API level 15, Ice Cream Sandwich for maximum compatibility.  This API level and above ensures that approximately 85\% of Android devices in the wild are compatible with the application\cite{androidAPInums}.  Due to UI components used in the application, namely fragments\cite{fragments}, it is not possible to support lower API levels as the functionality is not available.

There are two Android Activities which make up the ExICS client, the Login Activity which is launched when the ExICS launcher is selected on the Android launcher home screen or in the app-drawer, and the main Activity which shows the system state and facilitates communication with other users.

\begin{figure}[h]
	\centering
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/default_login"}
		\caption{Default Login Screen with Menu}
		\label{subfig:hidepassword}
	\end{subfigure}
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/login_show_pass"}
		\caption{Login Screen with Password Shown}
		\label{subfig:showpassword}
	\end{subfigure}
	\caption{ExICS Login Screen}
	\label{fig:exics_login}
\end{figure}

\FloatBarrier

The Login activity features a single screen with EditText\cite{androidEditText} view elements for entering college credentials and a button to attempt to login.  There are also toggles to remember login credentials, for use on personal devices, or to display the entered password in cleartext for  There is also a setting page, available through the Activity menu, allowing customisation of connection parameters, the ExICS server hostname and port.  The User Interface of the Login Screen can be seen in figure \ref{fig:exics_login}.

\FloatBarrier

The Login screen also features an ``About'' dialog giving information about the software and the reason it was created, as seen in figure \ref{subfig:login_about}.

All activities in the ExICS client are designed such that they are usable on any device or orientation.  In order to improve the UX (User Experience), Activities feature different portrait and landscape modes in order to take advantage of the screen real estate available, as in figure \ref{fig:login_landscape}.

\begin{figure}[h]
	\centering
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/about"}
		\caption{ExICS About Dialog}
		\label{subfig:login_about}
	\end{subfigure}
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/login_settings"}
		\caption{ExICS Login Configuration Settings}
		\label{subfig:login_settings}
	\end{subfigure}
	\caption{Additional Views in the Login Activity}
	\label{fig:exics_about_settings}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{"screenshots/login_landscape"}
	\caption{ExICS Login in Landscape Orientation}
	\label{fig:login_landscape}
\end{figure}

\FloatBarrier

\FloatBarrier

The second Activity is the main ExICS Activity which allows all of the main system functionality to be accessed, once the client has connected to the ExICS server.  This activity uses an android DrawerLayout\cite{navdrawer} which provides a menu which inflates when either the application icon in the top left of the activity is clicked, or when the user swipes right from the left edge of the screen.  This navigation draw exposes a listview of ``labels'' which can be clicked to select, which allows the application to change the content shown on the screen to that of the type selected by the user.  The activity showing the navigation drawer can be seen in figure \ref{fig:phone_nav_drawer}.

\begin{figure}
	\centering
	\includegraphics[width=0.35\textwidth]{"screenshots/phone_portrait_nav_drawer"}
	\caption{Phone Showing Navigation Drawer}
	\label{fig:phone_nav_drawer}
\end{figure}

The main content in the Activity is a partial Android activity known as a fragment.  Fragments have their own mini lifecycle\cite{visualisefragmentlifecycle} which is run within the parent Activity containing the fragment.  Fragments are used in order to enable multi-configuration supports so a UI on a small screen device, such as a phone, can contain a single fragment, a list of phone setting types for example, which when selected change the UI fragment displayed to show the phone settings themselves.  On a tablet device with a bigger screen, however, the UI could contain both fragments side by side, a parent fragment on the left with the list of setting types, and the content fragment on the right to display the settings in the category selected on the left.

\FloatBarrier

\FloatBarrier

The idea of supporting different device configurations such as screen orientation are embraced in the ExICS client and reflected particularly in the main Activity, as shown in figure \ref{fig:orientation_comparison}.  In portrait mode, the application displays a single fragment as in figure \ref{subfig:phone_portrait} which is displaying the room overview fragment.  When the screen is swiped left by the user, there is an animation and the view is replaced by the activity log fragment.  Similarly, when this view is swiped right, it is replaced with the original content.  As seen in figure \ref{subfig:tablet_landscape}, however, when the device is in landscape and so the screen is wider, both fragments are displayed side by side to take advantage of the screen space available.

\begin{figure}[h]
	\centering
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/phone_portrait_room_list"}
		\caption{Phone in Portrait}
		\label{subfig:phone_portrait}
	\end{subfigure}
	\begin{subfigure}[b]{0.35\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/phone_portrait_activity_log"}
		\caption{Phone in Portrait - Log}
		\label{subfig:phone_portrait_log}
	\end{subfigure}
	\newline
	\begin{subfigure}[b]{0.9\textwidth}
		\includegraphics[width=\textwidth]{"screenshots/tablet_main_landscape"}
		\caption{Tablet in Landscape}
		\label{subfig:tablet_landscape}
	\end{subfigure}
	\caption{Comparison of Tablet and Phone layouts in Different Orientation}
	\label{fig:orientation_comparison}
\end{figure}

\FloatBarrier

\section{ExICS Client Functionality}
\label{sec:ExICSfunctionality}

This section outlines the functionality provided by the ExICS client Android app.  The functionality is provided by the userinterface built upon the wsCommunicationManager and ExICSSystemData classes which handle the storing of system state and communication with the ExICS server.  The application uses a navigation drawer for navigation between different sections of the application as be can seen in figure \ref{fig:nav_drawer_phone}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=0.5\textwidth]{"screenshots/phone_portrait_nav_drawer"}
	\caption{ExICS Client's Main Navigation Feature - The Navigation Drawer}
	\label{fig:nav_drawer_phone}
\end{figure}

\FloatBarrier

The main functionality of the application, as accessible through each header in the navigation drawer will be outlined below.

\subsection{Overview}

The ExICS app gives an overview of all exams taking place during the current exam period.  The section uses a three view heirarchy which can be navigated as shown in figure \ref{fig:overview_flowchart}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=\textwidth]{"screenshots/overview_flowchart"}
	\caption{Flow of Navigation Through the Overview Screens}
	\label{fig:overview_flowchart}
\end{figure}

\FloatBarrier

The first screen shown is a list of rooms in which exams are taking place.  The number of invigilators in the room and the number of examinations running or paused are shown.  There is a home icon shown on the left of the ListView entry for the room in which the user is currently based.  On the right there is a status ``light'' for the room.  A red light means that one or more of the exams in the room are stopped, amber means that the exams in the room are all running but one or more needs attention as it is paused, and a green light means that all exams in the room are running as expected.

When a room row is selected in the room overview as shown with action one in figure \ref{fig:overview_flowchart}, that room is selected and the screen updates to show a list of exams taking place in that room.  This screen shows an entry for each exam taking place in the room during that session and gives a brief overview of the exam; its course code, scheduled start if stopped, actual start if running, the exam's duration and the scheduled end if stopped, or estimated end if running.  There is also a status light showing the status of the examination, red for stopped, yellow for paused and green for running.

When an exam is selected in the exam in room overview screen, as shown by action two in figure \ref{fig:overview_flowchart}, the application shows a detail page for the examination.  This page gives the details available about the current exam including number of questions, the exam's title and amount of extra time added to the exam.  As with the other views, it features a status ``light'' showing the state of the room.  At the bottom of the screen is the action bar which is dynamically modified depending upon the state of the room as shown in figure \ref{fig:exam_state_flow}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=\textwidth]{"screenshots/exam_state_flowchart"}
	\caption{Examination State Flow}
	\label{fig:exam_state_flow}
\end{figure}

\FloatBarrier

When the exam is paused, the status light is red.  The action bar contains only the action to start the examination.  When the exam is started a request is made, via the wsCommunicationManager, to the server which will attempt to start the selected exam.  If successful, the new system state with the exam started will be pushed to all connected clients which will trigger a STATE\_UPDATED broadcast to be made causing all views to be refreshed.  This will cause the exam detail page to update, with its status light changing to green.

When the exam is running, there are three actions which can be taken, pause the exam, add extra time, or stop the exam.  When clicked, these buttons trigger the appropriate request to be made by the wsCommunicationManager and, if successful, will cause the view to be updated.  When paused, the ``Pause Exam'' button is replaced with a ``Resume Exam'' button, and the status light changes to yellow.

When ``Add Extra Time'' is clicked, a dialog asking how much extra time is to be added is displayed to the user with a scrollable selector which when confirmed sends the request to the server to have the extra time added.  If successful, again, the server pushes the new system state to clients triggering the view to refresh, updating the ``Extra Time Added'' value, and recalculating the expected finish time.

When ``Stop Exam'' is selected, a warning confirmation is displayed to the user that the action cannot be undone, and if confirmed, the exam state is changed to complete, stored in the MongoDB database of completed exams, and the exam is removed from the system.  This causes all references to it in the overview screens to disappear.  If the exam was the only exam in the room it was located for example, the room will no longer appear in the room list, and users joining the system, or moving rooms once connected can no longer select to be based in that room.

\subsection{ExICS Log}
\label{subs:exics_log_expl}

The ExICS log screen is displayed to the right of all content displayed in the app.  In landscape mode, it is physically on screen to the right of the main content, or in portrait it can be reached by using a swiping gesture to the left.  Once displayed in portrait, the main content of the app can be shown by using a right swipe gesture.  The gesture implementation and details can be seen in section \ref{subs:chat_log_sliding}.

The ExICS log features two main components, the activity log itself, and an action button area below it as seen in figure \ref{fig:exics_log_phone_portrait}.  The activity log is a TextView housed within a ScrollView container which allows the user to scroll back through the activity history.  Each message has a timestamp for when the event occurred for reference.  Whenever a new event occurrs in the system, a new event is added to the log and the ScrollView container is scrolled to display it at the bottom of the activity log.  The means to achieve this autoscrolling is covered in section \ref{subs:log_autoscroll}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=0.5\textwidth]{"screenshots/phone_portrait_activity_log"}
	\caption{ExICS Log displayed in Portrait Mode on a Phone}
	\label{fig:exics_log_phone_portrait}
\end{figure}

\FloatBarrier

Below the activity log is a button which allows the user to send a message to other clients connected to the ExICS system.  When clicked, a dialog is displayed asking the user which kind of message they would like to send, a preset message, or a custom typed message.  Depending the type selected, the choice dialog is replaced with the dialog for creating the kind of message wanted.  The message recipients for both types of message can be customised and can be sent to all users, those in a specific room (including those who are ``delocalised'', staff moving between rooms or not directly based in a room invigilating such as admin staff), or to an individual.  If room or individual recipients are selected in the recipient type, a new drop down menu of the available rooms or recipients is displayed, allowing the user to choose.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=\textwidth]{"screenshots/send_message_flowchart"}
	\caption{Flowchart to Send a Message}
	\label{fig:send_message_flowchart}
\end{figure}

\FloatBarrier

Once the message is finalised, the wsCommunicationManager sends the message to the ExICS server which then forwards the message onto the intended recipients specified by their room or username.

When messages are recieved by the recipient, a dialog is displayed alerting them to the new message which gives details about the sender and their room, and gives the option for the recipient to reply to the original sender as shown in figure \ref{fig:message_screen}.

\subsection{Seating Plans}

The ExICS client allows the users to view seating plans for the rooms currently hosting exams.  It consistes of a room selector at the top of the screen, with a scrollable ListView of seating information for students taking exams in the room shown below, as seen in figure \ref{fig:spv}.

The seating plan information displays all of the information made available by the data source I was provided with by the department which is somewhat limited.  It consists of the seat number, the student taking the exam in that seats CID (College Identification) number, and the exam which they are sitting.  There is a wide array of information I would wish to display is addition to this, however given the timescale of the project and issues with data confidentiality, I was unable to obtain additional information such as student names and images as I would have wished.  These future development improvements and extensions are discussed further in section \ref{sec:future_work}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=0.5\textwidth]{"screenshots/t_p_sp"}
	\caption{Seating Plan View}
	\label{fig:spv}
\end{figure}

\FloatBarrier

\subsection{Invigilation Plan}

The final section of the activity of the ExICS client is the invigilation plan.  This screen simply consists of a checklist of action required to be carried out by the invigilator before, during and after the examination.  This information is not persisted between restarts and is simply intended to guide new invigilators or refresh the minds of experienced ones and allow them to tick of actions as they are completed.

In future it would be nice to add the ability to complete administrative tasks, such as post exam reports through the ExICS client which can they be pushed and stored in the MongoDB database for audit purposes amongst other things which will be discussed in more detail in the future work section of this report, \ref{sec:future_work}.

\section{User Interface Implementation}
\label{sec:UIimplementation}

This section will briefly outline some of the more interesting points of the ExICS Client Application Implementation.

\subsection{Sliding Chat Log}
\label{subs:chat_log_sliding}

When the device is in Portrait more and the screen is more tall than wide, having the activity log visible on screen alongside the main content doesn't make sense.  The content of the screen would be too small, at best bringing a poor UX, and at worst, rendering the entire appliation unusable.

It was therefore necessary to have only one fragment visible on the screen at any time.  It is important however to have both the main content of the app, and the activity log easily accessible and so decided to implement a swipe gesture which shows and hides the Activity Log as shown in figure \ref{fig:swipe_flowchart}.  When the main content of the application is showing, the user presses their finger onto the screen (1), moves it left (2) then lifts their finger in a left swipe gesture.  This triggers a fade animation in which the main content on the device screen is replaced with the ExICS log.  When the ExICS log is showing, the user then repeats the same gesture; start by pressing the screen (3), but instead of swiping their finger left, they swipe it right (4). This causes the same fade animation in which the main content screen of the application replaces the activity log and the user is back in the same position as they started.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=\textwidth]{"screenshots/flowchart"}
	\caption{Interaction with the Application Between Fragments to Show/Hide the Activity Log}
	\label{fig:swipe_flowchart}
\end{figure}

\FloatBarrier

\FloatBarrier

To implement this swipe gesture, the main activity layout for the portrait orientation contains three elements, the navigation drawer which is to the left of the screen, hidden offscreen to be displayed when triggered, and two fragment containers which occupy the same space on the screen and are of the same dimensions.  The main content fragment has its visibility set to View.VISIBLE, and that of the activity log fragment is set to View.GONE.  This means that, to the user it is as though there is only one fragment even present in the activity.

In the main activity Java code, a custom class, ``OnSwipeTouchListener'' is attached to the fragment containers which can recognize horizontal swipes and trigger a callback depending if the swipe detected is left or right as shown in figure \ref{fig:ostl}.  The gesture detector can be configured to tweak the length a swipe must be if the code is to be triggered and the velocity necessary for the swipe to be recognised.

\begin{figure}[!htpb]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	public class OnSwipeTouchListener implements View.OnTouchListener {
			private static final String TAG = OnSwipeTouchListener.class.getName();
			private final GestureDetector gestureDetector;

			public OnSwipeTouchListener(Context context) {
					gestureDetector = new GestureDetector(context, new GestureListener());
			}

			public void onSwipeLeft() {
			}

			public void onSwipeRight() {
			}

			public boolean onTouch(View v, MotionEvent event) {
					return gestureDetector.onTouchEvent(event);
			}

			private final class GestureListener extends GestureDetector.SimpleOnGestureListener {
					private static final int SWIPE_DISTANCE_THRESHOLD = 100;
					private static final int SWIPE_VELOCITY_THRESHOLD = 100;

					@Override
					public boolean onDown(MotionEvent e) {
							return true;
					}

					@Override
					public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
							Log.i(TAG, "OnSwipeTouchListener Fling");
							float distanceX = e2.getX() - e1.getX();
							float distanceY = e2.getY() - e1.getY();
							if (Math.abs(distanceX) > Math.abs(distanceY) && Math.abs(distanceX) > SWIPE_DISTANCE_THRESHOLD && Math.abs(velocityX) > SWIPE_VELOCITY_THRESHOLD) {
									if (distanceX > 0) onSwipeRight();
									else onSwipeLeft();
									return true;
							}
							return false;
					}
			}
	}
	\end{lstlisting}
	\caption{OnSwipeTouchListener}
	\label{fig:ostl}

\end{figure}

When the main activity is created, a function is called which determines the orientation of the device and if the screen is in portrait, swipe detectors are attached to the fragment containers.  The ``mainContent'' fragment has the ``onSwipeLeft'' method overridden in the swipe detector and the ``chatWindow'' fragment has the ``onSwipeRight'' method overridden.  These overridden methods contain one of two functions provided by the main activity, ``showChatLog'', or ``hideChatLog''.

The showChatLog and hideChatLog methods are responsible for updating the user interface when a swipe is detected.  This is done using a simple fade animation which takes 0.5 seconds to complete.  First, the opacity of the windows to be shown is set to 100\% and its visibility is set to View.Visible.  The animator then runs which interpolates the opacity of the two windows, with the window being replaced starting at 0\% and ends at 100\%, with the replacing windows starting at 100\% and ending at 0\%.  When the animator ends, the fragment container of the fragment being replaced has its visibility set to View.GONE so again, it is as if there is just one fragment.  The code for this animation can be found in figure \ref{fig:showChatLog}.

\begin{figure}[!htpb]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
		private void showChatLog() {
				final View contentWindow = findViewById(R.id.flMainContent);
				View chatWindow = findViewById(R.id.flChatWindow);

				chatWindow.setAlpha(0f);
				chatWindow.setVisibility(View.VISIBLE);

				chatWindow.animate()
								.alpha(1f)
								.setDuration(500)
								.setListener(null);

				contentWindow.animate()
								.alpha(0f)
								.setDuration(500)
								.setListener(new Animator.AnimatorListener() {
										@Override
										public void onAnimationStart(Animator animation) {
										}

										@Override
										public void onAnimationEnd(Animator animation) {
												contentWindow.setVisibility(View.GONE);
										}

										@Override
										public void onAnimationCancel(Animator animation) {
										}

										@Override
										public void onAnimationRepeat(Animator animation) {
										}
								});
				chatPaneShowing = true;
		}
	\end{lstlisting}
	\caption{Animator Code for showChatLog}
	\label{fig:showChatLog}
\end{figure}

Whilst this code works well for simple fragments containing no scrollable views, in fragments with interactive view components such as ScrollViews\cite{androidScrollView} or ListViews\cite{androidListView} I experienced a problem.  When the user attempts to make a swipe gesture in the fragment, and the starting position is a scrollable view, the scrollable view consumes the gesture such that the gesture detector listening on the parent fragment container did not detect them.

I spent a large amount of time trying to work around this problem in a nice way.  I attempted to intercept touches in the view heirarchy and to override the scrollable view's default behaviour such that the touch is passed back up the view heirarchy.  I also attempted to implement a ViewDragHelper\cite{androidViewDragHelper} which (seems to be) designed for this kind of purpose, however suffered greatly at the lack of guidance and documention on how the class works and so was unable to solve the issue this way.

As a work around, I implemented an interface between the child fragment and the parent activity with methods that can be called by the child fragment.  In the fragments, I simply attached OnSwipeTouchListeners to all scrollable components, overriding their ``onSwipeLeft'' and ``onSwipeRight'' methods such that when triggered by the gesture detector, they manually pass the event back to the parent activity using the defined interface.  This solution does work, and it works well, however, it is not as clean or sophisticated as I think could be possible, and so, given more time I would wish to implement a better means of intercepting and detecting gestures, even on fragments with scollable view widgets.

\FloatBarrier

\subsection{ExICS Log Autoscroll}
\label{subs:log_autoscroll}

With the activity log visible in the ExICS log section of the ExICS client application, as explained in section \ref{subs:exics_log_expl}, the contents are updated whenever a new event takes place such as messages being received, or exam states changing.  It is therefore desirable behaviour that the log would display the latest events visible in the log as they occur without the user having to scroll to the bottom of a log which is ever increasing in size.

The ScrollView containing in which the log, a TextView exists, is unaware of its own contents, and therefore does not provide any default functionality to allow such behaviour.  It was therefore necessary to find a way to implement this behaviour programmatically myself.

This is done with the code shown in figure \ref{fig:exics_log_update}.  Whenever the broadcast is received by the parent activity that the activity log has been updated, the parent invokes the refresh method on each child fragment.  In the case of the ExICS log fragment, this calls the ``updateLogText'' method.  This method refreshes the content of the activity log and then proceeds to programmatically scroll the containing ScrollView to the bottom of the log ensuring that the latest event is visible in the activity log.

\begin{figure}[!htpb]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	private void updateLogText() {
		if (logText != null) {
			logText.setText(exICSData.getChatLog());
			if (logScrollView != null) {
				logScrollView.post(new Runnable() {
					@Override
					public void run() {
							logScrollView.scrollTo(0, logText.getBottom());
					}
				});
			}
		}
	}
	\end{lstlisting}
	\caption{ExICS Log Update Method}
	\label{fig:exics_log_update}
\end{figure}

The scrolling of the ScrollView is done by posting a runnable task to the ScrollView which utilises the ScrollView's scrollTo method to scroll it to the bottom of the TextView it contains.  This code \textit{must} be executed as a runnable for compatibility reasons as \textit{some} implementations of Android, depending on device, will either not work, or crash the application if the main UI thread attempts to do the scrolling itself.  I found this whilst developing when the Nexus 7 device, provided by College and running pure Google Android, would allow the view to be scrolled directly, without the runnable, but my HTC One M7 with HTC Sense, would not.

\subsection{Handling Orientation Changes}
\label{subs:handling_orientation_changes}

By default, Android applications do not automatically handle orientation change cleanly due to Android's handling of orientation change.  When orientation changes, the current instance of the Activity is destroyed, and a new one with the new layout is created.  Whilst the handling of creating a new Activity with the correct orientation is automatic, activity state is not recreated.  For example, if an Activity contains an EditText\cite{androidEditText} UI view in which the user has started typing, when the device is rotated, the EditText will not be recreated with the contents still in place, it will be recreated empty.  The flow of methods called by the Android operating defining the Android Activity lifecycle can be seen in figure \ref{fig:android_lifecycle} and relates heavily to the issue of state management.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=0.5\textwidth]{"screenshots/android_lifecycle"}
	\caption{Android Activity Lifecycle\cite{androidLifecycle}}
	\label{fig:android_lifecycle}
\end{figure}

\FloatBarrier

There are a number of methods which can be used to ``handle'' orientation change without these side-effects and can be easily found on sites and blogs such as StackOverflow\cite{norotation}.  Solutions such as adding ``android:configChanges=\''orientation|screenSize\'''' to the AndroidManifest.xml file do work and cure the symptoms as this line instructs Android to not destroy the Activity when the device is rotated, to simply rescale the layout to fit the new display size.  Such ``hacks'', whilst they work to fix the original issue, introduce their own problems which cannot be so simple hidden.  Since the Activity is not restarted cleanly with the new UI layout, you cannot support multiple layouts on rotation without adding additional code to handle orientation change which adds additional complexity.

Whilst losing the content of EditText Views is annoying, it is not necessarily a big problem as the text can simply be retyped by the user.  The problem also affects other UI components however, such as Dialogs\cite{androidDialogs}.  When a message is received by the user, a dialog box displaying the message is shown to alert the user, allowing them to read the message, and to reply if necessary.  Since the event to trigger this code is a message being received and the MESSAGE\_RECEIVED broadcast being received, if the device is rotated and the dialog box is destroyed, when the activity is recreated, not only will the message dialog no longer be displayed, but since the message is held in an ArrayList of message objects, the message itself is lost.

To deal with the problem cleanly, the ExICS client takes advantage of an override method provided by the Android Activity class, ``onSaveInstanceState''.  This method is called just before an Activity is destroyed due to configuration changes and produces an Android Bundle which can contain primitives such as Strings, and serialisable or parcelable objects.

The onSaveInstanceState method is overriden and populated with activity state data, such as a serialised instance of the ArrayList containing current messages held in the Activity, and booleans for dialogs that are created ready to be displayed when triggered.

In the ``onCreate'' method of the Android lifecycle, a Bundle of existing instance state is passed in.  This Bundle is null if the activity is being created for the first time, i.e the activity has just been launched by the user.  If the Activity is being recreated following an orientation change, however, the ``outState'' Bundle created in ``onSaveInstanceState'' before the Activity was previously destroyed is passed to the new Activity instance.  At this point, application logic can be used to recreate system state, for example, reinstatiating the message ArrayList from the serialised version passed in the Bundle, or redisplaying Dialogs that were previously showing.

\subsection{Wake Device on Message Received}

One of the desired features of the client application was that it should clearly make the user aware of new messages that are received.  To save battery, Android devices go to sleep after a period of inactivity where the screen initially dims, then turns off, then the device locks, requiring the user to interact with the lock screen to reopen the device.

In the ExICS application I was able to take sample code found on StackOverflow\cite{awake_and_unlock} and shown in figure \ref{fig:unlockDevice}, to enable the application to programmatically wake an unlock the device if it has gone to sleep if required.

\begin{figure}[!htpb]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	// Called from onCreate
	protected void createWakeLocks(){
			PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
			fullWakeLock = powerManager.newWakeLock((PowerManager.SCREEN_BRIGHT_WAKE_LOCK | PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP), "Loneworker - FULL WAKE LOCK");
			partialWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Loneworker - PARTIAL WAKE LOCK");
	}

	// Called implicitly when device is about to sleep or application is backgrounded
	protected void onPause(){
			super.onPause();
			partialWakeLock.acquire();
	}

	// Called implicitly when device is about to wake up or foregrounded
	protected void onResume(){
			super.onResume();
			if(fullWakeLock.isHeld()){
					fullWakeLock.release();
			}
			if(partialWakeLock.isHeld()){
					partialWakeLock.release();
			}
	}

	// Called whenever we need to wake up the device
	public void wakeDevice() {
			fullWakeLock.acquire();

			KeyguardManager keyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
			KeyguardLock keyguardLock = keyguardManager.newKeyguardLock("TAG");
			keyguardLock.disableKeyguard();
	}
	\end{lstlisting}
	\caption{Code Allowing the Application to Awaken and Unlock a Sleeping Device Programmatically}
	\label{fig:unlockDevice}
\end{figure}

When the Activity is created, the ``createWakeLocks'' method is called which registers the activity with the powerManager.  In ``onPause'', the application acquires a partial wakelock, preventing the device from going into a deep sleep mode where the processor goes to sleep and network connectivity is lost which would kill the Websocket connection to the server.  In ``onResume'', if any wakelocks are held they are released.

When it is required to awaken the device while it is sleeping, the Activity can call the ``wakeDevice'' method which acquires a full wakelock which is registered to awaken the device when acquired in the ``createWakeLocks'' method.  This causes the device to awaken, and then disables the keyguard, unlocking the screen, and causing the Activity to be displayed.

This functionality is used whenever the MESSAGE\_RECEIVED broadcast is received by the application.  The message is extracted from the broadcast intent, and added to the ArrayList of messages. If the message dialog is not already showing, it is recreated displaying the newly received message and shown.  The ``wakeDevice'' method is then called, causing the device to wake up and reveal the application.  When the device awakens, the bright white message dialog is displayed in the center of the devices screen on a darkened background, as shown in figure \ref{fig:message_screen}.  If a message was already displaying, the screen is still woken, but a Toast\cite{androidToasts} with a long display duration is shown to alert the user that a new message has been received.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{"screenshots/tablet_portrait_message_roomlist"}
	\caption{ExICS Message Dialog}
	\label{fig:message_screen}
\end{figure}

\FloatBarrier

\subsection{Dynamic Buttons in Exam Detail}
\label{subs:exam_detail_buttons}

The exam detail screen reached by selecting an exam room, then an exam features an action area at the bottom of the screen with buttons, dynamically added to the view based upon exam state.  The buttons are dynamically generated based upon button type in the ExamDetailFragment to be dynamically sized height at 7/10ths of the height of the action bar.  This is to improve the aestetics of the fragment view.

It is possible to dynamically inflate views in Android at runtime, especially when using inbuilt dimension directives such as WRAP\_CONTENT or FILL\_PARENT as android can evaluate them whenever required to render the view.  What I was trying to do, however, was try and inflate the view to a specific dimension calculated as a function of the parent view's height, as shown in figure \ref{fig:actionButtons}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	private View getActionButton(int type, View parentView) {
				Log.i(TAG, "getActionButton");
				LinearLayout.LayoutParams lparams = new LinearLayout.LayoutParams((int) (parentView.getHeight() * 7.0 / 10.0), (int) (parentView.getHeight() * 7.0 / 10.0));
				View actionButton = getActivity().getLayoutInflater().inflate(R.layout.exam_detail_action_button_layout, null, false);
				actionButton.setLayoutParams(lparams);
				ImageView icon = (ImageView) actionButton.findViewById(R.id.ivButtonIcon);
				TextView text = (TextView) actionButton.findViewById(R.id.tvButtonTitle);
				switch (type) {
						case START_BUTTON:
								icon.setImageDrawable(getResources().getDrawable(android.R.drawable.ic_media_play));
								text.setText("Start Exam");
								break;
						...
				}
				return actionButton;
		}
	\end{lstlisting}
	\caption{Dynamic View Inflation of Action Buttons}
	\label{fig:actionButtons}
\end{figure}

\FloatBarrier

The getActionButton method takes the parent view of the action button, the action bar as a parameter and so it is possible to obtain the dimensions of the parent programmatically using the getHeight() and getWidth() methods of the class.

When I tried to do this however to populate the views when the fragment is attached to the parent Activity, I was finding that, apparently, no buttons were being added, or at least not that could be seen.  I took some debugging steps, such as logging the parent height as returned by the getHeight method when called on the parent, but what I found was that the buttons \textit{were} being created correctly, but that the returned height of the parent view was 0 pixels.  As a result, the buttons were being inflated to have a height and width of 7/10*0 pixels, or, 0 pixels.

This was caused by a timing issue with android and the way it does its rendering.  At the point the fragment is being attached, it has not yet been laid out by the Android rendering engine, a common issue experienced with those attempting to dynamically size UI elements in Android\cite{viewheight}.

To avoid the View's height returning 0 as it has not yet been drawn, it was necessary to make use of a ViewTreeObserver globalLayoutListener which is attached to the action bar of the fragment if the returned height of the View is 0.  The globalLayoutListener allows rendering events to be assigned callback functions to be executed during the rendering process, in this case, when the View is laid out in the fragment UI. At this point, the parent view now has a known height and width and so the getHeight method will no longer return 0.  At this point, the action buttons can now be programmatically inflated and added to the view with none-zero dimensions. The code achieving this is shown in figure \ref{fig:vto}.

\FloatBarrier

\begin{figure}[!htpb]
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[tabsize=2,breaklines=true]
	if (actionButtionPanel.getHeight() == 0) {
		ViewTreeObserver actionButtonPanelObserver = actionButtionPanel.getViewTreeObserver();
		actionButtonPanelObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
			@Override
			public void onGlobalLayout() {
				ViewTreeObserver obs = getView().findViewById(R.id.llExamDetailInteractionBar).getViewTreeObserver();
				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
					obs.removeOnGlobalLayoutListener(this);
				} else {
					obs.removeGlobalOnLayoutListener(this);
				}
				addActionButtons();
			}
		});
	} else {
		addActionButtons();
	}
	\end{lstlisting}
	\caption{ViewTreeObserver GlobalLayoutListener for Callbacks on Rendering Events}
	\label{fig:vto}
\end{figure}

\FloatBarrier