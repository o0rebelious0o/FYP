%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Daily Laboratory Book
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Frank Kuster (http://www.ctan.org/tex-archive/macros/latex/contrib/labbook/)
%
% Important note:
% This template requires the labbook.cls file to be in the same directory as the
% .tex file. The labbook.cls file provides the necessary structure to create the
% lab book.
%
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing lab book content.
%
% HOW TO USE THIS TEMPLATE 
% Each day in the lab consists of three main things:
%
% 1. LABDAY: The first thing to put is the \labday{} command with a date in 
% curly brackets, this will make a new page and put the date in big letters 
% at the top.
%
% 2. EXPERIMENT: Next you need to specify what experiment(s) you are 
% working on with an \experiment{} command with the experiment shorthand 
% in the curly brackets. The experiment shorthand is defined in the 
% 'DEFINITION OF EXPERIMENTS' section below, this means you can 
% say \experiment{pcr} and the actual text written to the PDF will be what 
% you set the 'pcr' experiment to be. If the experiment is a one off, you can 
% just write it in the bracket without creating a shorthand. Note: if you don't 
% want to have an experiment, just leave this out and it won't be printed.
%
% 3. CONTENT: Following the experiment is the content, i.e. what progress 
% you made on the experiment that day.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[idxtotoc,hyperref,openany]{labbook} % 'openany' here removes the gap page between days, erase it to restore this gap; 'oneside' can also be added to remove the shift that odd pages have to the right for easier reading

\usepackage[ 
  backref=page,
  pdfpagelabels=true,
  plainpages=false,
  colorlinks=true,
  bookmarks=true,
  pdfview=FitB]{hyperref} % Required for the hyperlinks within the PDF
  
\usepackage{booktabs} % Required for the top and bottom rules in the table
\usepackage{float} % Required for specifying the exact location of a figure or table
\usepackage{graphicx} % Required for including images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{listings}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Command to make the lines in the title page
% \setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	DEFINITION OF EXPERIMENTS
%----------------------------------------------------------------------------------------

\newexperiment{introduction}{Introduction to logbook}
\newexperiment{prior_work}{Prior Work}
\newexperiment{technology_investigation}{Technology Investigation}
\newexperiment{day_heading}{Days Work}
\newexperiment{auth}{System Authentication}

\newexperiment{node_tutorial}{Node.JS Tutorial}
\newexperiment{node_active_directory}{ActiveDirectory Authentication on Node.JS}

\newexperiment{node_websockets_LDAP}{LDAP Authentication for websocket connection on node}

\newexperiment{android_chat_initial}{Initial Work on Creating an Android Chat App}

\newexperiment{android_chat_continued}{Continuation of Android Chat App}

\newexperiment{progress_meetings}{Progress Meeting}

\newexperiment{exam_data_api_wrapper}{Exam Data API Wrapper}

\newexperiment{rewrite_api_wrapper}{Rewriting the API Wrapper}

\newexperiment{logbook_catchup}{Logbook Catchup}
\newexperiment{improved_json_date}{Improved JSON Structure for API}

\newexperiment{api_room_view}{Exam Data API Room View}
\newexperiment{api_documentation}{API Documentation}

\newexperiment{exics_exam_data_view}{ExICS Exam Data View}

\newexperiment{exics_advanced_view}{Advanced ExICS Exam Data View}

\newexperiment{seating_plan_api}{Exam Seating Plan API}

\newexperiment{meeting_with_mark_progress}{Progress Meeting With Mark}
\newexperiment{seating_plan_api_doc_course}{Improving the Seating Plan API}
\newexperiment{rewriting_the_ExICS_Server}{Rewriting the ExICS Server Code}

\newexperiment{further_ExICS_development}{Further Work on the ExICS Server}

\newexperiment{populating_exam_data_from_backend_api}{Populating the ExICS System Exam Data from Data API}

\newexperiment{further_work_15_may}{Further work on server}
\newexperiment{rewriting_the_logger}{Rewriting the Logger}

\experiment{android_app_ui_experiment}{Investigation into Android UI}

\experiment{android_app_start}{Starting work on the Android App}

\experiment{android_app_continued}{Continuation of Android App}


%---------------------------------------------------------------------------------------

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\frontmatter % Use Roman numerals for page numbers
\title{
\begin{center}
\HRule \\[0.4cm]
{\Huge \bfseries Final Year Project Logbook \\[0.5cm] \Large MEng EIE}\\[0.4cm] % Degree
\HRule \\[1.5cm]
\end{center}
}
\author{\Huge Richard Evans \\ \\ \LARGE rce10@ic.ac.uk \\[2cm]} % Your name and email address
\date{Beginning 31 Mar 2014} % Beginning date
\maketitle

\tableofcontents

\mainmatter % Use Arabic numerals for page numbers

%----------------------------------------------------------------------------------------
%	LAB BOOK CONTENTS
%----------------------------------------------------------------------------------------

% Blank template to use for new days:

%\labday{Day, Date Month Year}

%\experiment{}

%Text

%----------------------------------------------------------------------------------------

\labday{Monday, 31 March 2014}

\experiment{introduction}

I know that I actually began work on my FYP a lot sooner that the date shown here, but I was a bit lazy and didn't begin to keep a log book before now.  I haven't done a lot over the past term as I had a huge amount of coursework ongoing non-stop.  I will progress from now keeping proper record of what I do to make the writing of the final report easier.

\experiment{prior_work}

I have already completed a number of investigative steps for this coursework which I will quickly run over here.

I have already completed an investigation into the requirements of this project to compile a list of aims and objectives of what features the system implemented should have.  For this I conducted a number of face to face interviews with exam invigilators and head examiners.  I then created a simple surver which was completed by a number of staff involved with the examination process in both the Department of Computing and Electronic and Electrical engineering at Imperial.

With a list of aims and objective for feature implementation rated according to usefulness by the people that will use the system, I then prioritised the features into three distinct functionality goals, basic, necessary for the project to be considered successful, advanced, for desirable features and stretch goals which will be implemented should there be sufficient time.

With goals decided, I then created some initial design sketches of the application drawn to scale to give an idea of how the application could look and how the layout would look.

I then began experimenting with different technologies that could be used to see how to progress with implentation.

\experiment{technology_investigation}

There were multiple ways I could have implemented inter client communication including HTTP Long-polling, AJAX or technologies such as XMPP.  When I looked into these technologies, I realised that they were inefficient or did not provide the functionality required for the system.  Even XMPP, designed for chat clients, did not offer the features for communication the system would require.

I decided that I would make use of a (relatively) new technology, websockets.  Initially I thought I would make use of Socket.IO, running on Node.JS, an implementation of websockets wrapped with a protocol layer which would be useful and make my work simpler.  I found, however, that Socket.IO did not have any compatible android implementations.  It was therefore necessary to find a more basic websockets implementation and implement a higher level protocol myself.

I installed the following packages on a CloudStack Ubuntu 12.04 server:

\begin{itemize}
\item Node.JS v0.10.26
\item Node Package Manager (npm) v1.4.3
\item Websockets (ws) v0.4.31
\end{itemize}

For the android counterpart app, I am using the Android-Studio to develop with the Google Nexus 7 tablet in mind as the target device.

I am making use of the following libraries for the android code.

\begin{itemize}
\item targetSdkVersion 19
\item autobahn-0.5.0
\item jackson-core-asl-1.9.7
\item jackson-mapper-asl-1.9.7
\end{itemize}

\experiment{day_heading}

Today I have been busy catching up on where the project was left off as well as creating this log book and filling in previous work.

I have updated the version of Android Studio from 0.4.4 to 0.5.6 and done the accompanying changes to the android code necessary to make it compile under the new version.

I have then proceeded to look back through the existing node.JS app, and android code to refamiliarise with the code already written and to decide which direction to take next.

The server can currently set up a websockets listener and respond to incoming requests.  It supports identifying multiple users and passing information between clients based upon a simple API which defines the nature of the message received from a client.  The Android app is able to connect the Websockets server, identify itself and send messages to all other users connected to the server.

\experiment{auth}

One of the key features of the system which I am as yet to look into is authentication of users on the system.  I had previously contacted IT and the CSG teams and discussed the various college authentication services available.

Available platforms:

\begin{itemize}
\item Kerberos
\item Active Directory
\item LDAP
\end{itemize}

Kerberos, used for single sign on, isn't what I want, and so I was left to investigate LDAP and active directory.  Having taken a look around, I found a node.JS library called node-active directory which looks like it should do what I want.

https://github.com/gheeres/node-activedirectory

%----------------------------------------------------------------------------------------

\labday{Tuesday, 1 April 2014}

\experiment{node_tutorial}

In prior work I had rushed into quick investigations of the technologies I though would best suit the puposes of the project.  I am now going back to basics with Node.JS to begin with to get a better grasp of how it works and make sure I really understand node and how it works, and how best to use it.  The tutorials walked through writing basic console output, launching a basic HTTP server to listen on a port, through more advanced topics, async callback functions, creating node modules which can be included in apps and making use of post and get request parameters.

\experiment{node_active_directory}

Having got to grips with basic node.js topics, I moved on to investigate Active Exchange Authentication on Node.JS by creating a simple webpage on which you enter college credentials, and when submitted moves to a new page which does the LDAP authentication attempt and informs as to whether the LDAP auth was successful.

I did this using the node-activedirectory library I found yesterday.

I create an active directory object by binding to my own college credentials which are stored in their own node package to be included.  I then parse the received Post variables to extract the sent username and password, and do an LDAP authentication by attempting to bind the provided credentials.

This took a couple of hours to get working but works successfully and was relatively simple.  I spent a while before realising that the credentials provided need to have a fully qualified username, i.e <uname>@IC.AC.UK.  Once I appended this to the passed username, the system worked perfectly.

With the websocket aspect of the system working already following past work, and now college authentication working using LDAP, it should be possible to begin planning an implementation in greater detail.

%----------------------------------------------------------------------------------------

\labday{Thursday, 3 April 2014}

\experiment{node_websockets_LDAP}

At this point I have websockets working on both the node.js server, and in an Android application.  The behaviour of the websockets server can be verified through either a direct websockets connection such as using the chrome extension Dark WebSocket Terminal, or through a connection from an Android Application configured to connect to it.

I will now attempt to create a sample hybrid application to figure out how to create a protocol handshake such that new users connecting to the server will authenticate with it and be kicked if they fail.  Only then they can proceed to communicate with other users via the server.  If they attempt to negotiate with the server without authenticating they should also be kicked.

Great website for generating JSON strings easily: http://www.objgen.com/json

I have designed the protocol to work with a structure such as below, where the header is defined, but the payload can vary according to the nature of the packet.

\begin{lstlisting}
header
  type = 
  sender = 
  receiver = 
payload
  username = 
  password = 
  message = 
 \end{lstlisting}

 After a days work I have a server which is able to have multiple clients connect, authenticate them and kick if they misbehave.  Messages can be sent between connected users using the protocol laid out above.  Users can request to be disconnected from the server and it will be gracefully dealt with.

 \labday{Wednesday, 9 April 2014}

 \experiment{android_chat_initial}

 Having had almost a week off through illness and being on holiday for my Birthday, I came back to uni to continue with work on the project.

 With a working backend that has been verified by directly communicating using the websockets terminal in chrome, I began to work on an android application and basic user interfacce for a chat based application which allows me to pull in the work so far together to add android to the equation and see how that works out.

 I am using a single android application containing a FragmentContainer that will be updated to show the user interface.  Initially I am working on being able to do the login to the system.

 The user interface has two EditTexts, one for username, one for password.  When the Connect button is pressed the activity talks to the WebSocketClient class and negotiates a connection to the websocket server.  It then does the initial authentication protocol handshake, allowing it to be authenticated against the college LDAP server.

 By the end of the day I have the user interface made up and the app is able to connect, authenticate (this shows on the server terminal out) and that is it.

 \labday{Thursday, 10 April 2014}

 \experiment{android_chat_continued}

 Building on yesterday's work, I continued with the application, adding the actual chat screen itself with a simple scrollable TextView, an EditText for message input, and a submit button.  It is a very basic UI but is suitable for the purposes I need.

 When the WebSocketClient connects to the node server, it authenticates the user and waits to receive a Success response from the server.  At this point the WebSocketClient makes a local broadcast that the app connection status has changed.  This is then picked up by the application UI which switches the login fragment for the chat fragment.  Whenever messages are received, the WebSocketClient processes it and pushes the new message onto the chatLog which is stored in the GlobalData class.  A local broadcast that a new message has been received is then pushed which again is picked up by the activity which triggers a refresh of the chat log text view.

 When the user presses the back button, the WebSocketClient sends a disconnect request to the server and the application is closed.

 There are many things I could tweak which from an application perspective would make more sense, customize websocket server address in settings, save username and password, adjust the UI itself to make it better, but for now the application serves its purpose just great.

 I am happy with the progress that is being made.

 \labday{Wednesday, 23 April 2014}

 \experiment{progress_meetings}

 Having been away for a couple of weeks of Easter, I came back to work on the project by arranging a progress meeting with both Mark, who had also been away for easter, and Dr Thomas following a discussion of last term's HPCE.

 With Dr Thomas, I showed him my user interface sketches and discussed the principles of the system to ask his opinion.  He expressed a particular interest in the student ID barcode scanning feature proposed as a stretch goal, and the ability to do some of the admin associated with exam invigilation.  He also suggested the ability for the application to present a checklist of things TO-DO for invigilators at the various stages of the invigilation process; before, during, after etc.

 Following this dicussion I then went to speak to Mark to raise some of the issues regarding data feeds which had previously been stalling my work progress.

 I asked if it was possible to get a JSON version of the exam data API.  Apparently DoC is not interested in improving the data backend from a spreadsheet to a proper database, nor are they interested in rewriting the API to produce JSON instead of a CSV format.  Mark suggested that it would be nice if I could write an API wrapper which will present the data in JSON format by callingt he CSV API and parsing it.  This would also provide the ability to create multiple data views from the information which could prove useful in itself.

 We also discussed server customisation and how it would be nice for the server to read a configuration file on launch to affect behavior.  For example, how often to refresh its database from the data source, which database it is connecting to, the URL for the data source etc.  This would be good to design in as it means the resulting system is more portable.


 \labday{Thursday, 24 April 2014}

 \experiment{exam_data_api_wrapper}

 Following yesterdays meetings, I am writing a JSON API wrapper for the existing CSV API.  The API wrapper is being written in node.js and simply grabs the headers from the CSV and turns each row of the data set, delimited by tabs, into JSON objects which can be pushed into a JSON results array.

 These results are then returned to the caller.

 Having finished the API such that it can return the default view of data back to the caller, I have changed it so the data is instead prettyprinted.  This won't affect functionality when the data is being deserialized, but makes it nicer to inspect when using a browser to verify the correctness of the responses.


 \labday{Friday, 25 April 2014}

 \experiment{rewrite_api_wrapper}

 The API is working and returns correct data but its horribly hacky, all done in one .js file, contains username and password baked in.  This isn't great so I'm going to re-do it properly.

 I have split the functinality into multiple node.js modules which do one job and do it properly.

apiServer.js
csvWrapper.js
requestHandlers.js
ssl
csvConvert.js
examDataAPIServer.js
requestRouter.js

examDataAPIServer is the launchable app and instantiates the server specified in apiServer.  This uses the requestRouter module to parse the page requested from the server (which API in this case) and pass it to the requestHandlers module.  This module then looks at the GET variables passed, specifying the data view desired, and uses csvConvert to parse the response from the original API and create the JSON response.  This design is really flexible and permits the simple extension of the API to add more views by just adding new instances of the functions following the same template.

I currently have two views, default, and by day.  The day view relies on the data provided by the CSV data to be in chronological order of consecutive dates.

I then added security where the node.js server will require username and password to be provided, removing the need to have my credentials baked in to access the original API.  

\labday{Monday, 28 April 2014}

\experiment{logbook_catchup}

I have recently started doing all my work from in Windows as I have discovered amazing tools such as win-sshfs for remotemounting linux filesystems over ssh, as I had been in Linux and been using putty to ssh onto the server.  With this setup, I haven't needed to boot into my Linux system for weeks.

Unfortunately my logbook was stored on my Linux system, and whilst it was in a git repository I hadn't pushed the latest version in a couple of weeks.  Linux was broked following the last system update (*grrrr nVidia*) and so I needed to downgrade the kernel and nvidia drivers to get the system booting again.  From there I then pushed the latest versions of the codebase so I could switch back to windows.

Back in windows, I went to use latexing to backdate the past week of work in the logbook, but didn't have latexing in sublime set up correctly as I was missing texLive.

I set up latex on the machine properly and finished recording last weeks work so I don't fall too far behind and now here I am.

\experiment{improved_json_date}

With the logbook caught up on, I am now going back to work on the API wrapper.  I have a new view I want to implement at the request of Mark, by yeargroup.  And I also want to improve the structure of the date view which is already implemented.

Currently the by date view relies on the original data being in ascending date order, I intend to remove this requirement.  The structure at the moment is that `dates' is a JSON array containing a series of objects containing `date' and an array of objects representing the exams.

I intent to change `dates' to a JSON object containing a number of JSON Arrays, the keys to which are the exam dates.  This will allow for simple checking of ``if date in dates''.  For every exam data row parsed, I can therefore check if date is in dates, if so, push to existing array, else create and push.  This should be much better, and will also be the template for the by yeargroup api view to be finished today.

I have rewritten the date api view already implemented such that the results are a JSON object containing a number of JSON arrays rather than a single array containing a number of exam objects.  The keys to the JSON arrays are the dates of the exam days.

This new model has been carried forward to implement a new API view for `yeargroup'.  This view lists the exams grouped by the year group taking the exam based on the exam module code.

\labday{Wednesday, 30 April 2014}

\experiment{api_room_view}

To start with I have used the same response design as year group view to implement the data in a view grouped by room.  I will now implement a view extension to the date view in which exams are subgrouped into morning or afternoon sessions.

I have now implemented an API view where the exams are grouped by date, then subgrouped by morning or afternoon session with the time split between sessions defined as 13:00.

\experiment{api_documentation}

I decided that it would be useful to have an API documentation page which can be updated to show which API data views are available in a central location.  I implemented a new request handler for the API doc which serves up a HTML page with information regarding the API.  Should I change anything, this one page can now be updating avoiding the need to update users individually.

The API documentation can be found at https://146.169.44.162:8443/examData/apidoc.

\labday{Friday, 2 May 2014}

\experiment{exics_exam_data_view}

Today I extended the existing API data views to add one which is best for my system.  Returns a stright up array of all exams which are listed by the original CSV API.  The format slightly differs to the other API's, however.  Instead of giving the date and start time as they were, it creates a date object which is represented in ISO standard JSON form for compatibility in Zulu time.  It also contains an array of rooms which the exams are taking place in, and module names.

\labday{Tuesday, 6 May 2014}

\experiment{exics_advanced_view}

Having sketched up a preliminary system design, I decided it would reduce complexity in the back end system, improving performance if it was possible to query the API for a specific session, specifying beginning and end and only having dates within that session returned.

\labday{Thursday, 8 May 2014}

\experiment{seating_plan_api}

Mark has provided me a sample data source of seating data for last years exam session in tab separated value form.  In order to have access to this data programatically I have created an API which allows the data to be retrieved in JSON format and filtered by API parameters passed.  Currently I have implemented beginning and end of sessions and filtering by room the exam is being taken in.

\labday{Friday, 9 May 2014}

\experiment{meeting_with_mark_progress}

Having been busy working on APIs and not seeing Mark in a while, I met him for a progress meeting to discuss what I have done so far, any improvements of changes that could be made, my plan going forward, and goals.

The APIs I have created were received positively with a suggestion that for seating plans, accessing it and being able to filter by course could be useful.

My plan for the backend system is to fetch data from the exam data API as required to try and ensure it is as up to date as it possibly can be.

The running exams will be stored in an array or hashmap containing the exam status for the system.  As exams are started, these objects will be updated, and when finished they can be removed and pushed to a MongoDB database making the data persistent.

We discussed the benefits of a having a server log which records when any status changes are made and can be used to help diagnose and potential server issues.  This will in instead of/as well as the console log which I am currently using for checking system status.

Connected clients will be stored in an array as they are authenticated, allowing iteration to share updates with all clients.

Last time of update will be logged to ensure the examData is fetched only once as required per session.

I am currently unsure what I will do about seating plan information now I have the data available, whether to fetch it at the same time as the examData itself, or fetch on demand for whichever client wants it.

With regards to taking the register for those in the exam, Mark expressed an interest in a very simple interface where the details of the student appear onscreen and if all is well, the user just swipes left to advance to the next seat.  Only if something is amiss does the user have to tap a button on screen to make a note that a student was absent etc.

\experiment{seating_plan_api_doc_course}

Following the meeting with Mark, when I got home I continued work on the seating plan API.  I addded an extra API parameter for specifying course name and wrote an extra apiDoc page which details the seating plan API and how to use it.

\experiment{rewriting_the_ExICS_Server}

I had already written a large body of code for the ExICS server which was functioning correctly.  It was, however, written in a couple of big long horrible scripts.  My first step was to break the code down into several much smaller modules responsible for individual aspects of server functionality.

I broke the code down and migrated it across into the correct part of the new codebase.  I then went through and modified the existing references in the code to fit the new modular design.

I then decided a few loose global scope variables were not the best way to hold the system state and so implemented a singleton object for holding and mutating such data.

\labday{Tuesday, 13 May 2014}

\experiment{further_ExICS_development}

Having done the migration to the new codebase structure, it was necessary to test that it maintained the correct functionality from before.  To begin with I worked through a websocket terminal to directly send messages to the server and inspect the responses.

Once I could verify the server behaviour using the websockets terminal, I rebuilt the original Android application I had working with the past version and updated the server URL to point to the new server port.  Again, the app worked correctly and so I could move on to implementing new functionality and restructuring the existing code.

I restructured some of the existing code so it made more sense structurally, separating unathorised and authorised behaviour, and improving readability.

I began to implement the data fetch and synchronization from the exam data API.  This involves three markers, morning session begin, morning session end/afternoon session begin, and afternoon session end.  There is an object which logs when the last synchronization was completed.  Using this infomation the system can track whether an update is required, and if so, update the system state accordingly.

\labday{Wednesday, 14 May 2014}

\experiment{populating_exam_data_from_backend_api}

With the basic structure for calculating exam session and fetching data from the API accordingly, I have created a means of injecting ``Mock'' data information into the system, so that I can ensure data will be fetched from the API by forcing the system to a day and session which has exam data in the API data source.

Today has been very productive.  I can now synchronize data from the feeding API to hold in the system.  I have written the code to check if synchronization is necessary, and if it is, fetch the data from the feeder API, process it and store it as an internal system state.

I have extended the system protocol to add new packets for starting and stopping exams, I have changed the design so that once authenticated, you receive the current running exams and connected users, as well as their rooms.  I improved system stability, added a spin lock for receiving refreshed exam information so you can't receive it while the data is being modified.

I've remoddelled some of the packet designs for what is contained within different types of message.  This is and will still be a work in progress as things progress.

Modified some of the behaviour to use objects for example instead of arrays for connectedClients.  This allows me to take advantage of the hashmap structure to directly access sockets for a known user instread of traversing the array to find the socket, boosting performance.

\labday{Thursday, 15 May 2014}

\experiment{further_work_15_may}

I have been through the source code and tidied it up, refactored slightly to improve readability and code performance, as well as removing node module files which were created but aren't actually being used.

With the codebase looking tidier, I continued to add functionality to the system.

I modified the examData API exics view so that exam objects use a single string for the exam/submodule tag, rather than an array of the various names a module may have, as this isn't really important for the system and removes complexity.

With the API modified, I completed the code for synchronizing with the server, fixing a couple of bugs and redesigning the locking mechanism to boost performance.

With this working, I implemented new functionality to start, pause, stop and add extra time to exams.

I fixed some behavioural bugs with users termimating connections which was causing the server to crash by trying to send updates to sockets which had already been closed following a request from the client.  This was caused by a change in how the connectedClients object was updated to track rooms as well as sockets for connected users.

I went through and improved some logging for the system to better record events happening in the system, allowing verification of intended behaviour.

\experiment{rewriting_the_logger}

I decided now would be a good time to polish up the system a bit more and rewrite the logger.  So far, all that was done for logging through my logger was that it would prepend a message that was to be logged with a ISO standard dateTime stamp before writing it to the console.

This was fine up until now but I want to start improving the system and making it more polished.  To do this, I have completely rewritten the logger.

The logger is implemented as a singleton object which when created, opens a write stream to a log file in logs/<date>/<ISO\_timestamp>.txt.  There are a number of log levels specified, and the default can be set when the object is first instantiated.

A log message can be recorded using log([level], message).  With this, if a log level parameter, either numeric or in text form, it will be logged to both the console, and the log file with the timestamp and log level specified.

I added some code to do some last minute processing, like closing the log gracefully before the process exits.

I had a couple of bugs to fix with file permissions for creating folders, and it took me a while to figure out I couldn't open the log files on windows as files can't contain `:'.  I fixed the issue by replacing `:' characters with `.'.

\labday{Friday, 16 May 2014}

\experiment{android_app_ui_experiment}

The server is more or less up and running as expected for now and I am ready to begin writing the android client side app for the system.  I have ideas for how I want the android app to look involving swipe views and navigation drawers.  Before jumping into coding I have started by looking at tutorials on android development with regards to user interfaces, split pane views and gesture recognizers so that left and right swipe gestures can be recognized and the UI updated accordingly.

This involved learning about fragments as these are the main UI views modern Android applications utilise.  This makes it easy to specify differing user interfaces across device types and screen orientations.

\labday{Tuesday, 20 May 2014}

\experiment{android_app_start}

Having experimented with different user interface designs, fragments, split pane views and navigation drawers, I am now ready to start writing the ExICS app properly.  I am planning on writing from the ground up with clean code of a production standard, handling different screne orientations and device types properly.

\labday{Wednesday, 21 May 2014}

\experiment{android_app_continued}

%----------------------------------------------------------------------------------------
%	FORMULAE AND MEDIA RECIPES
%----------------------------------------------------------------------------------------

\labday{} % We don't want a date here so we make the labday blank

\begin{center}
\HRule \\[0.4cm]
{\huge \textbf{Formulae and Media Recipes}}\\[0.4cm] % Heading
\HRule \\[1.5cm]
\end{center}

%----------------------------------------------------------------------------------------
%	MEDIA RECIPES
%----------------------------------------------------------------------------------------

\newpage

%-----------------------------------------

%\textbf{Media 2}\\ \\

%Description

%----------------------------------------------------------------------------------------
%	FORMULAE
%----------------------------------------------------------------------------------------

\newpage

%-----------------------------------------

%\textbf{Formula X - Description}\\ \\

%Formula

%----------------------------------------------------------------------------------------

\end{document}