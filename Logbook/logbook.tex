%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Daily Laboratory Book
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Frank Kuster (http://www.ctan.org/tex-archive/macros/latex/contrib/labbook/)
%
% Important note:
% This template requires the labbook.cls file to be in the same directory as the
% .tex file. The labbook.cls file provides the necessary structure to create the
% lab book.
%
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing lab book content.
%
% HOW TO USE THIS TEMPLATE 
% Each day in the lab consists of three main things:
%
% 1. LABDAY: The first thing to put is the \labday{} command with a date in 
% curly brackets, this will make a new page and put the date in big letters 
% at the top.
%
% 2. EXPERIMENT: Next you need to specify what experiment(s) you are 
% working on with an \experiment{} command with the experiment shorthand 
% in the curly brackets. The experiment shorthand is defined in the 
% 'DEFINITION OF EXPERIMENTS' section below, this means you can 
% say \experiment{pcr} and the actual text written to the PDF will be what 
% you set the 'pcr' experiment to be. If the experiment is a one off, you can 
% just write it in the bracket without creating a shorthand. Note: if you don't 
% want to have an experiment, just leave this out and it won't be printed.
%
% 3. CONTENT: Following the experiment is the content, i.e. what progress 
% you made on the experiment that day.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[idxtotoc,hyperref,openany]{labbook} % 'openany' here removes the gap page between days, erase it to restore this gap; 'oneside' can also be added to remove the shift that odd pages have to the right for easier reading

\usepackage[ 
  backref=page,
  pdfpagelabels=true,
  plainpages=false,
  colorlinks=true,
  bookmarks=true,
  pdfview=FitB]{hyperref} % Required for the hyperlinks within the PDF
  
\usepackage{booktabs} % Required for the top and bottom rules in the table
\usepackage{float} % Required for specifying the exact location of a figure or table
\usepackage{graphicx} % Required for including images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage{listings}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Command to make the lines in the title page
% \setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	DEFINITION OF EXPERIMENTS
%----------------------------------------------------------------------------------------

\newexperiment{introduction}{Introduction to logbook}
\newexperiment{prior_work}{Prior Work}
\newexperiment{technology_investigation}{Technology Investigation}
\newexperiment{day_heading}{Days Work}
\newexperiment{auth}{System Authentication}

\newexperiment{node_tutorial}{Node.JS Tutorial}
\newexperiment{node_active_directory}{ActiveDirectory Authentication on Node.JS}

\newexperiment{node_websockets_LDAP}{LDAP Authentication for websocket connection on node}

\newexperiment{android_chat_initial}{Initial Work on Creating an Android Chat App}

\newexperiment{android_chat_continued}{Continuation of Android Chat App}

\newexperiment{progress_meetings}{Progress Meeting}

\newexperiment{exam_data_api_wrapper}{Exam Data API Wrapper}

\newexperiment{rewrite_api_wrapper}{Rewriting the API Wrapper}

\newexperiment{logbook_catchup}{Logbook Catchup}
\newexperiment{improved_json_date}{Improved JSON Structure for API}

%---------------------------------------------------------------------------------------

\begin{document}

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\frontmatter % Use Roman numerals for page numbers
\title{
\begin{center}
\HRule \\[0.4cm]
{\Huge \bfseries Final Year Project Logbook \\[0.5cm] \Large MEng EIE}\\[0.4cm] % Degree
\HRule \\[1.5cm]
\end{center}
}
\author{\Huge Richard Evans \\ \\ \LARGE rce10@ic.ac.uk \\[2cm]} % Your name and email address
\date{Beginning 31 Mar 2014} % Beginning date
\maketitle

\tableofcontents

\mainmatter % Use Arabic numerals for page numbers

%----------------------------------------------------------------------------------------
%	LAB BOOK CONTENTS
%----------------------------------------------------------------------------------------

% Blank template to use for new days:

%\labday{Day, Date Month Year}

%\experiment{}

%Text

%----------------------------------------------------------------------------------------

\labday{Monday, 31 March 2014}

\experiment{introduction}

I know that I actually began work on my FYP a lot sooner that the date shown here, but I was a bit lazy and didn't begin to keep a log book before now.  I haven't done a lot over the past term as I had a huge amount of coursework ongoing non-stop.  I will progress from now keeping proper record of what I do to make the writing of the final report easier.

\experiment{prior_work}

I have already completed a number of investigative steps for this coursework which I will quickly run over here.

I have already completed an investigation into the requirements of this project to compile a list of aims and objectives of what features the system implemented should have.  For this I conducted a number of face to face interviews with exam invigilators and head examiners.  I then created a simple surver which was completed by a number of staff involved with the examination process in both the Department of Computing and Electronic and Electrical engineering at Imperial.

With a list of aims and objective for feature implementation rated according to usefulness by the people that will use the system, I then prioritised the features into three distinct functionality goals, basic, necessary for the project to be considered successful, advanced, for desirable features and stretch goals which will be implemented should there be sufficient time.

With goals decided, I then created some initial design sketches of the application drawn to scale to give an idea of how the application could look and how the layout would look.

I then began experimenting with different technologies that could be used to see how to progress with implentation.

\experiment{technology_investigation}

There were multiple ways I could have implemented inter client communication including HTTP Long-polling, AJAX or technologies such as XMPP.  When I looked into these technologies, I realised that they were inefficient or did not provide the functionality required for the system.  Even XMPP, designed for chat clients, did not offer the features for communication the system would require.

I decided that I would make use of a (relatively) new technology, websockets.  Initially I thought I would make use of Socket.IO, running on Node.JS, an implementation of websockets wrapped with a protocol layer which would be useful and make my work simpler.  I found, however, that Socket.IO did not have any compatible android implementations.  It was therefore necessary to find a more basic websockets implementation and implement a higher level protocol myself.

I installed the following packages on a CloudStack Ubuntu 12.04 server:

\begin{itemize}
\item Node.JS v0.10.26
\item Node Package Manager (npm) v1.4.3
\item Websockets (ws) v0.4.31
\end{itemize}

For the android counterpart app, I am using the Android-Studio to develop with the Google Nexus 7 tablet in mind as the target device.

I am making use of the following libraries for the android code.

\begin{itemize}
\item targetSdkVersion 19
\item autobahn-0.5.0
\item jackson-core-asl-1.9.7
\item jackson-mapper-asl-1.9.7
\end{itemize}

\experiment{day_heading}

Today I have been busy catching up on where the project was left off as well as creating this log book and filling in previous work.

I have updated the version of Android Studio from 0.4.4 to 0.5.6 and done the accompanying changes to the android code necessary to make it compile under the new version.

I have then proceeded to look back through the existing node.JS app, and android code to refamiliarise with the code already written and to decide which direction to take next.

The server can currently set up a websockets listener and respond to incoming requests.  It supports identifying multiple users and passing information between clients based upon a simple API which defines the nature of the message received from a client.  The Android app is able to connect the Websockets server, identify itself and send messages to all other users connected to the server.

\experiment{auth}

One of the key features of the system which I am as yet to look into is authentication of users on the system.  I had previously contacted IT and the CSG teams and discussed the various college authentication services available.

Available platforms:

\begin{itemize}
\item Kerberos
\item Active Directory
\item LDAP
\end{itemize}

Kerberos, used for single sign on, isn't what I want, and so I was left to investigate LDAP and active directory.  Having taken a look around, I found a node.JS library called node-active directory which looks like it should do what I want.

https://github.com/gheeres/node-activedirectory

%----------------------------------------------------------------------------------------

\labday{Tuesday, 1 April 2014}

\experiment{node_tutorial}

In prior work I had rushed into quick investigations of the technologies I though would best suit the puposes of the project.  I am now going back to basics with Node.JS to begin with to get a better grasp of how it works and make sure I really understand node and how it works, and how best to use it.  The tutorials walked through writing basic console output, launching a basic HTTP server to listen on a port, through more advanced topics, async callback functions, creating node modules which can be included in apps and making use of post and get request parameters.

\experiment{node_active_directory}

Having got to grips with basic node.js topics, I moved on to investigate Active Exchange Authentication on Node.JS by creating a simple webpage on which you enter college credentials, and when submitted moves to a new page which does the LDAP authentication attempt and informs as to whether the LDAP auth was successful.

I did this using the node-activedirectory library I found yesterday.

I create an active directory object by binding to my own college credentials which are stored in their own node package to be included.  I then parse the received Post variables to extract the sent username and password, and do an LDAP authentication by attempting to bind the provided credentials.

This took a couple of hours to get working but works successfully and was relatively simple.  I spent a while before realising that the credentials provided need to have a fully qualified username, i.e <uname>@IC.AC.UK.  Once I appended this to the passed username, the system worked perfectly.

With the websocket aspect of the system working already following past work, and now college authentication working using LDAP, it should be possible to begin planning an implementation in greater detail.

%----------------------------------------------------------------------------------------

\labday{Thursday, 3 April 2014}

\experiment{node_websockets_LDAP}

At this point I have websockets working on both the node.js server, and in an Android application.  The behaviour of the websockets server can be verified through either a direct websockets connection such as using the chrome extension Dark WebSocket Terminal, or through a connection from an Android Application configured to connect to it.

I will now attempt to create a sample hybrid application to figure out how to create a protocol handshake such that new users connecting to the server will authenticate with it and be kicked if they fail.  Only then they can proceed to communicate with other users via the server.  If they attempt to negotiate with the server without authenticating they should also be kicked.

Great website for generating JSON strings easily: http://www.objgen.com/json

I have designed the protocol to work with a structure such as below, where the header is defined, but the payload can vary according to the nature of the packet.

\begin{lstlisting}
header
  type
  sender
  receiver
payload
  username
  password
  message
 \end{lstlisting}

 After a days work I have a server which is able to have multiple clients connect, authenticate them and kick if they misbehave.  Messages can be sent between connected users using the protocol laid out above.  Users can request to be disconnected from the server and it will be gracefully dealt with.

 \labday{Wednesday, 9 April 2014}

 \experiment{android_chat_initial}

 Having had almost a week off through illness and being on holiday for my Birthday, I came back to uni to continue with work on the project.

 With a working backend that has been verified by directly communicating using the websockets terminal in chrome, I began to work on an android application and basic user interfacce for a chat based application which allows me to pull in the work so far together to add android to the equation and see how that works out.

 I am using a single android application containing a FragmentContainer that will be updated to show the user interface.  Initially I am working on being able to do the login to the system.

 The user interface has two EditTexts, one for username, one for password.  When the Connect button is pressed the activity talks to the WebSocketClient class and negotiates a connection to the websocket server.  It then does the initial authentication protocol handshake, allowing it to be authenticated against the college LDAP server.

 By the end of the day I have the user interface made up and the app is able to connect, authenticate (this shows on the server terminal out) and that is it.

 \labday{Thursday, 10 April 2014}

 \experiment{android_chat_continued}

 Building on yesterday's work, I continued with the application, adding the actual chat screen itself with a simple scrollable TextView, an EditText for message input, and a submit button.  It is a very basic UI but is suitable for the purposes I need.

 When the WebSocketClient connects to the node server, it authenticates the user and waits to receive a Success response from the server.  At this point the WebSocketClient makes a local broadcast that the app connection status has changed.  This is then picked up by the application UI which switches the login fragment for the chat fragment.  Whenever messages are received, the WebSocketClient processes it and pushes the new message onto the chatLog which is stored in the GlobalData class.  A local broadcast that a new message has been received is then pushed which again is picked up by the activity which triggers a refresh of the chat log text view.

 When the user presses the back button, the WebSocketClient sends a disconnect request to the server and the application is closed.

 There are many things I could tweak which from an application perspective would make more sense, customize websocket server address in settings, save username and password, adjust the UI itself to make it better, but for now the application serves its purpose just great.

 I am happy with the progress that is being made.

 \labday{Wednesday, 23 April 2014}

 \experiment{progress_meetings}

 Having been away for a couple of weeks of Easter, I came back to work on the project by arranging a progress meeting with both Mark, who had also been away for easter, and Dr Thomas following a discussion of last term's HPCE.

 With Dr Thomas, I showed him my user interface sketches and discussed the principles of the system to ask his opinion.  He expressed a particular interest in the student ID barcode scanning feature proposed as a stretch goal, and the ability to do some of the admin associated with exam invigilation.  He also suggested the ability for the application to present a checklist of things TO-DO for invigilators at the various stages of the invigilation process; before, during, after etc.

 Following this dicussion I then went to speak to Mark to raise some of the issues regarding data feeds which had previously been stalling my work progress.

 I asked if it was possible to get a JSON version of the exam data API.  Apparently DoC is not interested in improving the data backend from a spreadsheet to a proper database, nor are they interested in rewriting the API to produce JSON instead of a CSV format.  Mark suggested that it would be nice if I could write an API wrapper which will present the data in JSON format by callingt he CSV API and parsing it.  This would also provide the ability to create multiple data views from the information which could prove useful in itself.

 We also discussed server customisation and how it would be nice for the server to read a configuration file on launch to affect behavior.  For example, how often to refresh its database from the data source, which database it is connecting to, the URL for the data source etc.  This would be good to design in as it means the resulting system is more portable.


 \labday{Thursday, 24 April 2014}

 \experiment{exam_data_api_wrapper}

 Following yesterdays meetings, I am writing a JSON API wrapper for the existing CSV API.  The API wrapper is being written in node.js and simply grabs the headers from the CSV and turns each row of the data set, delimited by tabs, into JSON objects which can be pushed into a JSON results array.

 These results are then returned to the caller.

 Having finished the API such that it can return the default view of data back to the caller, I have changed it so the data is instead prettyprinted.  This won't affect functionality when the data is being deserialized, but makes it nicer to inspect when using a browser to verify the correctness of the responses.


 \labday{Friday, 25 April 2014}

 \experiment{rewrite_api_wrapper}

 The API is working and returns correct data but its horribly hacky, all done in one .js file, contains username and password baked in.  This isn't great so I'm going to re-do it properly.

 I have split the functinality into multiple node.js modules which do one job and do it properly.

apiServer.js
csvWrapper.js
requestHandlers.js
ssl
csvConvert.js
examDataAPIServer.js
requestRouter.js

examDataAPIServer is the launchable app and instantiates the server specified in apiServer.  This uses the requestRouter module to parse the page requested from the server (which API in this case) and pass it to the requestHandlers module.  This module then looks at the GET variables passed, specifying the data view desired, and uses csvConvert to parse the response from the original API and create the JSON response.  This design is really flexible and permits the simple extension of the API to add more views by just adding new instances of the functions following the same template.

I currently have two views, default, and by day.  The day view relies on the data provided by the CSV data to be in chronological order of consecutive dates.

I then added security where the node.js server will require username and password to be provided, removing the need to have my credentials baked in to access the original API.  

\labday{Monday, 28 April 2014}

\experiment{logbook_catchup}

I have recently started doing all my work from in Windows as I have discovered amazing tools such as win-sshfs for remotemounting linux filesystems over ssh, as I had been in Linux and been using putty to ssh onto the server.  With this setup, I haven't needed to boot into my Linux system for weeks.

Unfortunately my logbook was stored on my Linux system, and whilst it was in a git repository I hadn't pushed the latest version in a couple of weeks.  Linux was broked following the last system update (*grrrr nVidia*) and so I needed to downgrade the kernel and nvidia drivers to get the system booting again.  From there I then pushed the latest versions of the codebase so I could switch back to windows.

Back in windows, I went to use latexing to backdate the past week of work in the logbook, but didn't have latexing in sublime set up correctly as I was missing texLive.

I set up latex on the machine properly and finished recording last weeks work so I don't fall too far behind and now here I am.

\experiment{improved_json_date}

With the logbook caught up on, I am now going back to work on the API wrapper.  I have a new view I want to implement at the request of Mark, by yeargroup.  And I also want to improve the structure of the date view which is already implemented.

Currently the by date view relies on the original data being in ascending date order, I intend to remove this requirement.  The structure at the moment is that `dates' is a JSON array containing a series of objects containing `date' and an array of objects representing the exams.

I intent to change `dates' to a JSON object containing a number of JSON Arrays, the keys to which are the exam dates.  This will allow for simple checking of ``if date in dates''.  For every exam data row parsed, I can therefore check if date is in dates, if so, push to existing array, else create and push.  This should be much better, and will also be the template for the by yeargroup api view to be finished today.

%----------------------------------------------------------------------------------------
%	FORMULAE AND MEDIA RECIPES
%----------------------------------------------------------------------------------------

\labday{} % We don't want a date here so we make the labday blank

\begin{center}
\HRule \\[0.4cm]
{\huge \textbf{Formulae and Media Recipes}}\\[0.4cm] % Heading
\HRule \\[1.5cm]
\end{center}

%----------------------------------------------------------------------------------------
%	MEDIA RECIPES
%----------------------------------------------------------------------------------------

\newpage

%-----------------------------------------

%\textbf{Media 2}\\ \\

%Description

%----------------------------------------------------------------------------------------
%	FORMULAE
%----------------------------------------------------------------------------------------

\newpage

%-----------------------------------------

%\textbf{Formula X - Description}\\ \\

%Formula

%----------------------------------------------------------------------------------------

\end{document}